000001 0000                  ;======================================================================
000002 0000                  ;-- Robot Variables
000003 0000                  ;======================================================================
000004 0000                  
000005 0000                  ;======================================================================
000006 0000                  ;-- Internal memory layout
000007 0000                  ;======================================================================
000008 0000                  ;-- System variables at start of general purpose memory area
000009 0020                              .equ    varbase,    020h          ; start in bitmapped area
000010 0020                              .equ    vmflags,    varbase + 0   ; 1 byte for flags (bit mapped)
000011 0021                              .equ    vmsflag,    varbase + 1   ; 1 byte spare flags byte
000012 0022                              .equ    countdn,    varbase + 2   ; countdown byte for timing
000013 0023                              .equ    tickvect,   varbase + 3   ; 2 bytes for tick chaining vector (low,high)
000014 0025                              .equ    vpscratc,   varbase + 5   ; 8 bytes for virtual machine workspace					 
000015 002D                              .equ    dramaloc,   varbase + 13  ; 2 bytes for top of allocated data mem ptr
000016 002F                              .equ    state,      varbase + 15  ; 2 bytes for current state (pt to event records)
000017 0031                              .equ    stcnt,      varbase + 17  ; 1 byte for count of event records for this state
000018 0033                              .equ    vmfltc,     varbase + 19  ; 1 byte Virtual machine fault code.
000019 0034                              .equ    vmrstk,     varbase + 20  ; 2 bytes virtual machine return stack base.
000020 0036                              .equ    events,     varbase + 22  ; 2 byte pointer to event table
000021 0038                              .equ    stable,     varbase + 24  ; 2 byte pointer to state table
000022 003A                              .equ    stemap,     varbase + 26  ; 2 byte pointer to the event map for the current state.
000023 003C                              .equ    image,      varbase + 28  ; 2 byte pointer to image being executed.
000024 0000                              
000025 0040                              .equ    vmestk,     040h          ; Virtual machine eval stack base
000026 0000                  
000027 0000                  ; Alias the scratch area for arithmetic routines.
000028 0025                              .equ op_0,vpscratc
000029 0026                              .equ op_1,vpscratc+1
000030 0027                              .equ op_2,vpscratc+2
000031 0028                              .equ op_3,vpscratc+3
000032 0029                              .equ tmp_0,vpscratc+4
000033 002A                              .equ tmp_1,vpscratc+5
000034 002B                              .equ tmp_2,vpscratc+6
000035 002C                              .equ tmp_3,vpscratc+7
000036 0000                  
000037 0000                  
000038 0000                  ; -- bit addresses for virtual machine flags - map to vmFlags byte
000039 0000                              .equ    vmfStop,    00h ; - flag set when VM stopped
000040 0001                              .equ    vmChk,      01h ; - turn on extra run-time checks if set
000041 0002                              .equ    vmsign,     02h ; - flag to negate result of arithmetic
000042 0003                              .equ    vmsgn2,     03h ; - second flag for sign of arithmetic results.
000043 0000                  
000044 0000                  ;======================================================================
000045 0000                  ;-- External memory layout
000046 0000                  ;======================================================================
000047 0000                              .equ    evtabl,     0000h         ; location of event table.
000048 0000                  ;======================================================================
000049 0000                  ; MONITOR.ASM
000050 0000                  ; Machine code monitor main program
000051 0000                  ;
000052 0000                  ; Resources:
000053 0000                  ; T0 - main timing interrupt.
000054 0000                  ; T1 - baud rate generator.
000055 0000                  ; P3.2:P3.5 - Dual I2C master.
000056 0000                  ;======================================================================
000057 0000                  
000058 0000                  ;======================================================================
000059 0000                  ; Define interrupt vectors at start of dual mapped ram
000060 0000                  ;======================================================================
000061 0000                              .equ rambase,0000h      ; ToDO - figure out how this works at start of dual mapped ram, below this EPROM or Data RAM.  8000 gives error 201 - overflow.
000062 0020                              .equ intIE0,rambase+32
000063 0040                              .equ intTF0,rambase+64
000064 0060                              .equ intIE1,rambase+96
000065 0080                              .equ intTF1,rambase+128
000066 00A0                              .equ intCom,rambase+160
000067 00C0                              .equ intTF2,rambase+192
000068 0100                              .equ user,rambase+256
000069 0000                  
000070 0000                  ;======================================================================
000071 0000                  ;-- Reset & interrupt vectors
000072 0000                  ;======================================================================
000073 0000                              .org    0000h
000074 0000 802C                         sjmp    monitor     ;jump over interrupt vectors
000075 0003                              .org    0003h       ;IE0 external interrupt 0 vector
000076 0003 020020                       ljmp    intIE0
000077 000B                              .org    000Bh       ;TF0 timer/counter 0 interrupt vector
000078 000B 0206F5                       ljmp    timeint     ;direct to main timing interrupt
000079 0013                              .org    0013h       ;IE1 external interrupt 1 vector
000080 0013 020060                       ljmp    intIE1
000081 001B                              .org    001Bh       ;TF1 timer/counter 1 interrupt vector
000082 001B 020080                       ljmp    intTF1
000083 0023                              .org    0023h       ;serial interrupt vector.
000084 0023 0200A0                       ljmp    intCom
000085 002B                              .org    002Bh       ;T2
000086 002B 0200C0                       ljmp    intTF2
000087 002E                  
000088 002E                  
000089 002E                  
000090 002E                  ;======================================================================
000091 002E                  ;-- Hardware equates
000092 002E                  ;======================================================================
000093 002E                  
000094 002E                  ;======================================================================
000095 002E                  ; Bit addresses of i2c lines, 2 software I2C masters, I2C-A and I2CB
000096 002E                  ;======================================================================
000097 00B3                                  .equ sda_a,P3.3         ; bit address of I2C-A SDA
000098 00B2                                  .equ scl_a,P3.2         ; bit address of I2C-A SCL
000099 00B5                                  .equ sda_b,P3.5         ; bit address of I2C-B SDA
000100 00B4                                  .equ scl_b,P3.4         ; bit address of I2C-B SCL
000101 002E                  
000102 002E                  
000103 002E                  ;======================================================================
000104 002E                  ;-- Start of main user program
000105 002E                  ;-- Runs the simple monitor program.
000106 002E                  ;======================================================================
000107 002E 75817F           monitor:    mov sp, #7Fh        ; 8032: start stack at start of top 128 bytes
000108 0031                                                  ; 8031: start stack at #2Fh just above bit addressable area
000109 0031 759000                       mov     p1,#0       ; Make sure motors off.
000110 0034                  
000111 0034                              ; clear internal memory to 0 (ignore stack area)
000112 0034 7800                         mov     r0,#08      ; start above first register bank
000113 0036 7978                         mov     r1,#120     ; for first 128 bytes less first register bank
000114 0038 7600             mclrlp:     mov     @r0,#0      ; clear byte
000115 003A 08                           inc     r0          ; next
000116 003B D9FB                         djnz    r1,mclrlp
000117 003D                  
000118 003D                              ; init the hardware
000119 003D 1206E0                       lcall   timinit     ; set timer interrupt
000120 0040 1205CA                       lcall   scominit    ; init the serial comms
000121 0043                  
000122 0043                              ;Output logon message
000123 0043 9000B1                       mov     dptr,#logmsg1
000124 0046 B1E8                         acall   scomtxc
000125 0048 9000C7                       mov     dptr,#logmsg2
000126 004B B1E8                         acall   scomtxc
000127 004D 9000E5                       mov     dptr,#logmsg3
000128 0050 B1E8                         acall   scomtxc
000129 0052                  
000130 0052                  
000131 0052                  ;-- monitor main loop
000132 0052 90011B           monloop:    mov     dptr,#rdymsg ; ready prompt
000133 0055 B1E8                         acall   scomtxc
000134 0057 D1A6                         acall   scomrxa     ; look for command character
000135 0059 B43A04                       cjne    a,#':',monnorm ; a normal character if not a :
000136 005C 91D6                         acall   ihexinlp    ; after initial : has been read
000137 005E 80F2                         sjmp    monloop
000138 0060                  
000139 0060 C3               monnorm:    clr     c           ; for sub
000140 0061 9440                         subb    a,#'@'      ; map @->0, A->1 etc
000141 0063 541F                         anl     a,#31       ; force into range 0..31
000142 0065 23                           rl      a           ; 2 bytes per table entry
000143 0066 900052                       mov     dptr,#monloop ; set up return address
000144 0069 C082                         push    dpl         ; push low byte of return address
000145 006B C083                         push    dph         ; push high byte of return address
000146 006D 900071                       mov     dptr,#monjmp ; pointer to monitor jump table
000147 0070 73                           jmp     @a+dptr     ; jump to table
000148 0071                  
000149 0071                  ;-- vectored jump table to monitor commands            
000150 0071 2125             monjmp:     ajmp   notimp      ; @
000151 0073 2125                         ajmp   notimp      ; A
000152 0075 2125                         ajmp   notimp      ; B
000153 0077 2175                         ajmp   monrdcod    ; C - read code byte
000154 0079 2125                         ajmp   notimp      ; D
000155 007B A1C2                         ajmp   echo        ; E - echo characters (until .)
000156 007D 2125                         ajmp   notimp      ; F
000157 007F 2125                         ajmp   notimp      ; G
000158 0081 2125                         ajmp   notimp      ; H
000159 0083 81D4                         ajmp   ihexin      ; I - read intelhex file into data memory
000160 0085 A1AE                         ajmp   vjump       ; J - jump to location
000161 0087 2125                         ajmp   notimp      ; K
000162 0089 2125                         ajmp   notimp      ; L
000163 008B 2125                         ajmp   notimp      ; M
000164 008D 2125                         ajmp   notimp      ; N
000165 008F 2149                         ajmp   monrdmem    ; 0 - read from internal memory
000166 0091 213B                         ajmp   monwrmem    ; P - write to intenral memory
000167 0093 2125                         ajmp   notimp      ; Q
000168 0095 2125                         ajmp   notimp      ; R
000169 0097 612D                         ajmp   monrdsfr    ; S - SFR read aa
000170 0099 2185                         ajmp   monwrsfr    ; T - SFR write aa,dd
000171 009B 2125                         ajmp   notimp      ; U
000172 009D 2125                         ajmp   notimp      ; V
000173 009F 2125                         ajmp   notimp      ; W
000174 00A1 2166                         ajmp   monrdx      ; X - read from external memory
000175 00A3 2159                         ajmp   monwrx      ; Y - write to external memory
000176 00A5 212A                         ajmp   stop        ; Z - stop & power down
000177 00A7 2125                         ajmp   notimp      ; [
000178 00A9 2125                         ajmp   notimp      ; \
000179 00AB 2125                         ajmp   notimp      ; ]
000180 00AD 2125                         ajmp   notimp      ; ^
000181 00AF 2125                         ajmp   notimp      ; _
000182 00B1                  
000183 00B1 383043333220526F logmsg1:    .db     "80C32 Robot Monitor\r\n\0"
       00B9 626F74204D6F6E69
       00C1 746F720D0A00    
000184 00C7 416C766167656D20 logmsg2:    .db     "Alvagem Software 1999-2011 \r\n\0"
       00CF 536F667477617265
       00D7 20313939392D3230
       00DF 3131200D0A00    
000185 00E5 496E636C7564696E logmsg3:    .db     "Including Virtual Machine\r\n\0"
       00ED 6720566972747561
       00F5 6C204D616368696E
       00FD 650D0A00        
000186 0101 436F6D6D616E6420 notimsg:    .db     "Command not implemented\r\n\0"
       0109 6E6F7420696D706C
       0111 656D656E7465640D
       0119 0A00            
000187 011B 52656164793E00   rdymsg:     .db     "Ready>\0"
000188 0122 0D0A00           crlf:       .db     "\r\n\0"
000189 0125                  
000190 0125                  ;======================================================================
000191 0125                  ; notimp
000192 0125                  ; prints a "Command not implemented" message
000193 0125                  ;======================================================================
000194 0125 900101           notimp:     mov     dptr,#notimsg   ; not implemented message
000195 0128 A1E8                         ajmp    scomtxc         ; print and return
000196 012A                  
000197 012A                  ;======================================================================
000198 012A                  ; stop
000199 012A                  ; stops the processor where possible
000200 012A                  ;======================================================================
000201 012A 900134           stop:       mov     dptr,#stopmsg
000202 012D B1E8                         acall   scomtxc
000203 012F 438702                       orl     pcon,#02h   ; go into power down if CMOS processor
000204 0132 80F6                         sjmp    stop        ; infinite loop
000205 0134 53746F700D0A00   stopmsg:    .db "Stop\r\n\0"
000206 013B                  
000207 013B                  ;======================================================================
000208 013B                  ; monwrmem 
000209 013B                  ; This reads a byte address (in hex), a comma, and data byte(in hex)
000210 013B                  ; from the serial port ands writes to the given address in internal
000211 013B                  ; memory
000212 013B                  ;======================================================================
000213 013B D1AE             monwrmem:   acall   scomrhx8        ; get addr in A
000214 013D F8                           mov     r0,A            ; save for indirect write later
000215 013E D1A6                         acall   scomrxa         ; get comma and discard
000216 0140 D1AE                         acall   scomrhx8        ; get data byte to write 
000217 0142 F6                           mov     @r0,A           ;
000218 0143 900122                       mov     dptr,#crlf
000219 0146 B1E8                         acall   scomtxc
000220 0148 22                           ret
000221 0149                  
000222 0149                  ;======================================================================
000223 0149                  ; monrdmem 
000224 0149                  ; This reads a byte address (in hex) from the serial port, reads the
000225 0149                  ; internal memory at that address, and sends the value back, in hex
000226 0149                  ; down the serial port
000227 0149                  ;======================================================================
000228 0149 D1AE             monrdmem:   acall   scomrhx8        ; get addr in A
000229 014B F8                           mov     r0,A            ; setup for indirect fetch
000230 014C 742D                         mov     A,#'-'          ; separator char
000231 014E B1E0                         acall   scomtxa
000232 0150 E6                           mov     A,@r0           ; get the byte
000233 0151 B1FB                         acall   scomtx8         ; and send it back to host
000234 0153 900122                       mov     dptr,#crlf
000235 0156 B1E8                         acall   scomtxc
000236 0158 22                           ret
000237 0159                  
000238 0159                  ;======================================================================
000239 0159                  ; monwrx 
000240 0159                  ; This reads a 16 bit address (in hex), a comma, and data byte(in hex)
000241 0159                  ; from the serial port ands writes to the given address in external
000242 0159                  ; memory
000243 0159                  ;======================================================================
000244 0159 D1CB             monwrx:     acall   scomrh16        ; 16 bit addr in dptr
000245 015B D1A6                         acall   scomrxa         ; get comma and discard
000246 015D D1AE                         acall   scomrhx8        ; get data byte to write 
000247 015F F0                           movx    @dptr,a         
000248 0160 900122                       mov     dptr,#crlf
000249 0163 B1E8                         acall   scomtxc
000250 0165 22                           ret
000251 0166                  
000252 0166                  ;======================================================================
000253 0166                  ; monrdx
000254 0166                  ; This reads a 16 bit address (in hex) from the serial port, reads the
000255 0166                  ; external memory at that address, and sends the value back, in hex
000256 0166                  ; down the serial port
000257 0166                  ;======================================================================
000258 0166 D1CB             monrdx:     acall   scomrh16        ; 16 bit addr in dptr
000259 0168 742D                         mov     A,#'-'          ; separator char
000260 016A B1E0                         acall   scomtxa
000261 016C E0                           movx    a,@dptr         ; get the data byte
000262 016D B1FB                         acall   scomtx8         ; and send it back to host
000263 016F 900122                       mov     dptr,#crlf
000264 0172 B1E8                         acall   scomtxc
000265 0174 22                           ret
000266 0175                  
000267 0175                  ;======================================================================
000268 0175                  ; monrdcod
000269 0175                  ; This reads a 16 bit address (in hex) from the serial port, reads the
000270 0175                  ; code memory at that address, and sends the value back, in hex
000271 0175                  ; down the serial port
000272 0175                  ;======================================================================
000273 0175 D1CB             monrdcod:   acall   scomrh16        ; 16 bit addr in dptr
000274 0177 742D                         mov     A,#'-'          ; separator char
000275 0179 B1E0                         acall   scomtxa
000276 017B E4                           clr     a               ; don't want offset for movc
000277 017C 93                           movc    a,@a+dptr       ; get the data byte
000278 017D B1FB                         acall   scomtx8         ; and send it back to host
000279 017F 900122                       mov     dptr,#crlf
000280 0182 B1E8                         acall   scomtxc
000281 0184 22                           ret
000282 0185                  
000283 0185                  ;======================================================================
000284 0185                  ; monwrsfr 
000285 0185                  ; This reads a byte address (in hex), a comma, and data byte(in hex)
000286 0185                  ; from the serial port ands writes to the given Special Function 
000287 0185                  ; Register(SFR).  This uses  direct addressing to ensure we get the 
000288 0185                  ; SFRs on an 8032, hence there is a mov A,nn; ret for every possible 
000289 0185                  ; SFR entry and a vectored jump done by computing the target 
000290 0185                  ; address in the table, pushing that address and doing a ret.
000291 0185                  ;======================================================================
000292 0185 9001A7           monwrsfr:   mov     dptr,#monwrsrr  ; setup return address for vectored call
000293 0188 C082                         push    dpl
000294 018A C083                         push    dph
000295 018C                  
000296 018C D1AE                         acall   scomrhx8    ; get sfr byte address
000297 018E 547F                         anl     a,#127      ;map 128-255 to 0-127 (sfrs all >= 128)
000298 0190 F5F0                         mov     b,a         ; save address in b
000299 0192 7403                         mov     a,#3        ; each entry in code table is 3 bytes
000300 0194 A4                           mul     ab          ; convert to offset into code table
000301 0195 9001AD                       mov     dptr,#monwrsft ; address of code table
000302 0198 2582                         add     a,dpl
000303 019A C0E0                         push    acc         ; set up low byte of jump addr on stack
000304 019C E5F0                         mov     a,b
000305 019E 3583                         addc    a,dph
000306 01A0 C0E0                         push    acc         ; set  up high byte of jump address on stack
000307 01A2 D1A6                         acall   scomrxa     ; get comma (& ignore)
000308 01A4 D1AE                         acall   scomrhx8    ; get value to write in a
000309 01A6 22                           ret                 ; pop jump addr off stack & go to it (vectored jump)
000310 01A7                  
000311 01A7 900122           monwrsrr:   mov     dptr,#crlf
000312 01AA B1E8                         acall   scomtxc
000313 01AC 22                           ret                 ; from routine
000314 01AD                  
000315 01AD F580             monwrsft:   mov      128 ,A
000316 01AF 22                           ret
000317 01B0 F581                         mov      129 ,A
000318 01B2 22                           ret
000319 01B3 F582                         mov      130 ,A
000320 01B5 22                           ret
000321 01B6 F583                         mov      131 ,A
000322 01B8 22                           ret
000323 01B9 F584                         mov      132 ,A
000324 01BB 22                           ret
000325 01BC F585                         mov      133 ,A
000326 01BE 22                           ret
000327 01BF F586                         mov      134 ,A
000328 01C1 22                           ret
000329 01C2 F587                         mov      135 ,A
000330 01C4 22                           ret
000331 01C5 F588                         mov      136 ,A
000332 01C7 22                           ret
000333 01C8 F589                         mov      137 ,A
000334 01CA 22                           ret
000335 01CB F58A                         mov      138 ,A
000336 01CD 22                           ret
000337 01CE F58B                         mov      139 ,A
000338 01D0 22                           ret
000339 01D1 F58C                         mov      140 ,A
000340 01D3 22                           ret
000341 01D4 F58D                         mov      141 ,A
000342 01D6 22                           ret
000343 01D7 F58E                         mov      142 ,A
000344 01D9 22                           ret
000345 01DA F58F                         mov      143 ,A
000346 01DC 22                           ret
000347 01DD F590                         mov      144 ,A
000348 01DF 22                           ret
000349 01E0 F591                         mov      145 ,A
000350 01E2 22                           ret
000351 01E3 F592                         mov      146 ,A
000352 01E5 22                           ret
000353 01E6 F593                         mov      147 ,A
000354 01E8 22                           ret
000355 01E9 F594                         mov      148 ,A
000356 01EB 22                           ret
000357 01EC F595                         mov      149 ,A
000358 01EE 22                           ret
000359 01EF F596                         mov      150 ,A
000360 01F1 22                           ret
000361 01F2 F597                         mov      151 ,A
000362 01F4 22                           ret
000363 01F5 F598                         mov      152 ,A
000364 01F7 22                           ret
000365 01F8 F599                         mov      153 ,A
000366 01FA 22                           ret
000367 01FB F59A                         mov      154 ,A
000368 01FD 22                           ret
000369 01FE F59B                         mov      155 ,A
000370 0200 22                           ret
000371 0201 F59C                         mov      156 ,A
000372 0203 22                           ret
000373 0204 F59D                         mov      157 ,A
000374 0206 22                           ret
000375 0207 F59E                         mov      158 ,A
000376 0209 22                           ret
000377 020A F59F                         mov      159 ,A
000378 020C 22                           ret
000379 020D F5A0                         mov      160 ,A
000380 020F 22                           ret
000381 0210 F5A1                         mov      161 ,A
000382 0212 22                           ret
000383 0213 F5A2                         mov      162 ,A
000384 0215 22                           ret
000385 0216 F5A3                         mov      163 ,A
000386 0218 22                           ret
000387 0219 F5A4                         mov      164 ,A
000388 021B 22                           ret
000389 021C F5A5                         mov      165 ,A
000390 021E 22                           ret
000391 021F F5A6                         mov      166 ,A
000392 0221 22                           ret
000393 0222 F5A7                         mov      167 ,A
000394 0224 22                           ret
000395 0225 F5A8                         mov      168 ,A
000396 0227 22                           ret
000397 0228 F5A9                         mov      169 ,A
000398 022A 22                           ret
000399 022B F5AA                         mov      170 ,A
000400 022D 22                           ret
000401 022E F5AB                         mov      171 ,A
000402 0230 22                           ret
000403 0231 F5AC                         mov      172 ,A
000404 0233 22                           ret
000405 0234 F5AD                         mov      173 ,A
000406 0236 22                           ret
000407 0237 F5AE                         mov      174 ,A
000408 0239 22                           ret
000409 023A F5AF                         mov      175 ,A
000410 023C 22                           ret
000411 023D F5B0                         mov      176 ,A
000412 023F 22                           ret
000413 0240 F5B1                         mov      177 ,A
000414 0242 22                           ret
000415 0243 F5B2                         mov      178 ,A
000416 0245 22                           ret
000417 0246 F5B3                         mov      179 ,A
000418 0248 22                           ret
000419 0249 F5B4                         mov      180 ,A
000420 024B 22                           ret
000421 024C F5B5                         mov      181 ,A
000422 024E 22                           ret
000423 024F F5B6                         mov      182 ,A
000424 0251 22                           ret
000425 0252 F5B7                         mov      183 ,A
000426 0254 22                           ret
000427 0255 F5B8                         mov      184 ,A
000428 0257 22                           ret
000429 0258 F5B9                         mov      185 ,A
000430 025A 22                           ret
000431 025B F5BA                         mov      186 ,A
000432 025D 22                           ret
000433 025E F5BB                         mov      187 ,A
000434 0260 22                           ret
000435 0261 F5BC                         mov      188 ,A
000436 0263 22                           ret
000437 0264 F5BD                         mov      189 ,A
000438 0266 22                           ret
000439 0267 F5BE                         mov      190 ,A
000440 0269 22                           ret
000441 026A F5BF                         mov      191 ,A
000442 026C 22                           ret
000443 026D F5C0                         mov      192 ,A
000444 026F 22                           ret
000445 0270 F5C1                         mov      193 ,A
000446 0272 22                           ret
000447 0273 F5C2                         mov      194 ,A
000448 0275 22                           ret
000449 0276 F5C3                         mov      195 ,A
000450 0278 22                           ret
000451 0279 F5C4                         mov      196 ,A
000452 027B 22                           ret
000453 027C F5C5                         mov      197 ,A
000454 027E 22                           ret
000455 027F F5C6                         mov      198 ,A
000456 0281 22                           ret
000457 0282 F5C7                         mov      199 ,A
000458 0284 22                           ret
000459 0285 F5C8                         mov      200 ,A
000460 0287 22                           ret
000461 0288 F5C9                         mov      201 ,A
000462 028A 22                           ret
000463 028B F5CA                         mov      202 ,A
000464 028D 22                           ret
000465 028E F5CB                         mov      203 ,A
000466 0290 22                           ret
000467 0291 F5CC                         mov      204 ,A
000468 0293 22                           ret
000469 0294 F5CD                         mov      205 ,A
000470 0296 22                           ret
000471 0297 F5CE                         mov      206 ,A
000472 0299 22                           ret
000473 029A F5CF                         mov      207 ,A
000474 029C 22                           ret
000475 029D F5D0                         mov      208 ,A
000476 029F 22                           ret
000477 02A0 F5D1                         mov      209 ,A
000478 02A2 22                           ret
000479 02A3 F5D2                         mov      210 ,A
000480 02A5 22                           ret
000481 02A6 F5D3                         mov      211 ,A
000482 02A8 22                           ret
000483 02A9 F5D4                         mov      212 ,A
000484 02AB 22                           ret
000485 02AC F5D5                         mov      213 ,A
000486 02AE 22                           ret
000487 02AF F5D6                         mov      214 ,A
000488 02B1 22                           ret
000489 02B2 F5D7                         mov      215 ,A
000490 02B4 22                           ret
000491 02B5 F5D8                         mov      216 ,A
000492 02B7 22                           ret
000493 02B8 F5D9                         mov      217 ,A
000494 02BA 22                           ret
000495 02BB F5DA                         mov      218 ,A
000496 02BD 22                           ret
000497 02BE F5DB                         mov      219 ,A
000498 02C0 22                           ret
000499 02C1 F5DC                         mov      220 ,A
000500 02C3 22                           ret
000501 02C4 F5DD                         mov      221 ,A
000502 02C6 22                           ret
000503 02C7 F5DE                         mov      222 ,A
000504 02C9 22                           ret
000505 02CA F5DF                         mov      223 ,A
000506 02CC 22                           ret
000507 02CD F5E0                         mov      224 ,A
000508 02CF 22                           ret
000509 02D0 F5E1                         mov      225 ,A
000510 02D2 22                           ret
000511 02D3 F5E2                         mov      226 ,A
000512 02D5 22                           ret
000513 02D6 F5E3                         mov      227 ,A
000514 02D8 22                           ret
000515 02D9 F5E4                         mov      228 ,A
000516 02DB 22                           ret
000517 02DC F5E5                         mov      229 ,A
000518 02DE 22                           ret
000519 02DF F5E6                         mov      230 ,A
000520 02E1 22                           ret
000521 02E2 F5E7                         mov      231 ,A
000522 02E4 22                           ret
000523 02E5 F5E8                         mov      232 ,A
000524 02E7 22                           ret
000525 02E8 F5E9                         mov      233 ,A
000526 02EA 22                           ret
000527 02EB F5EA                         mov      234 ,A
000528 02ED 22                           ret
000529 02EE F5EB                         mov      235 ,A
000530 02F0 22                           ret
000531 02F1 F5EC                         mov      236 ,A
000532 02F3 22                           ret
000533 02F4 F5ED                         mov      237 ,A
000534 02F6 22                           ret
000535 02F7 F5EE                         mov      238 ,A
000536 02F9 22                           ret
000537 02FA F5EF                         mov      239 ,A
000538 02FC 22                           ret
000539 02FD F5F0                         mov      240 ,A
000540 02FF 22                           ret
000541 0300 F5F1                         mov      241 ,A
000542 0302 22                           ret
000543 0303 F5F2                         mov      242 ,A
000544 0305 22                           ret
000545 0306 F5F3                         mov      243 ,A
000546 0308 22                           ret
000547 0309 F5F4                         mov      244 ,A
000548 030B 22                           ret
000549 030C F5F5                         mov      245 ,A
000550 030E 22                           ret
000551 030F F5F6                         mov      246 ,A
000552 0311 22                           ret
000553 0312 F5F7                         mov      247 ,A
000554 0314 22                           ret
000555 0315 F5F8                         mov      248 ,A
000556 0317 22                           ret
000557 0318 F5F9                         mov      249 ,A
000558 031A 22                           ret
000559 031B F5FA                         mov      250 ,A
000560 031D 22                           ret
000561 031E F5FB                         mov      251 ,A
000562 0320 22                           ret
000563 0321 F5FC                         mov      252 ,A
000564 0323 22                           ret
000565 0324 F5FD                         mov      253 ,A
000566 0326 22                           ret
000567 0327 F5FE                         mov      254 ,A
000568 0329 22                           ret
000569 032A F5FF                         mov      255 ,A
000570 032C 22                           ret
000571 032D                  
000572 032D                  ;======================================================================
000573 032D                  ; monrdsfr 
000574 032D                  ; This reads a byte address (in hex) from the serial port,
000575 032D                  ; reads from the given Special Function Register(SFR) and returns
000576 032D                  ; the value read as 2 hex digits.
000577 032D                  ; This uses  direct addressing to ensure we get the 
000578 032D                  ; SFRs on an 8032, hence there is a mov A,nn; ret for every possible 
000579 032D                  ; SFR entry and a vectored jump done by computing the target 
000580 032D                  ; address in the table, pushing that address and doing a ret.
000581 032D                  ;======================================================================
000582 032D D1AE             monrdsfr:   acall   scomrhx8
000583 032F                              
000584 032F F8                           mov     r0,a
000585 0330 742D                         mov     A,#'-'          ; separator char
000586 0332 B1E0                         acall   scomtxa
000587 0334 E8                           mov     a,r0
000588 0335                  
000589 0335 547F                         anl     a,#127      ;map 128-255 to 0-127 (sfrs all >= 128)
000590 0337 7141                         acall   monrdsfj    ;read sfr given address in a
000591 0339 B1FB                         acall   scomtx8     ;send back a hex byte
000592 033B 900122                       mov     dptr,#crlf
000593 033E B1E8                         acall   scomtxc
000594 0340 22                           ret
000595 0341 F5F0             monrdsfj:   mov     b,a         ;save address in b
000596 0343 7403                         mov     a,#3        ; each entry in code table is 3 bytes
000597 0345 A4                           mul     ab          ; convert to offset into code table
000598 0346 900354                       mov     dptr,#monrdsft ; address of code table
000599 0349 2582                         add     a,dpl
000600 034B C0E0                         push    acc         ; set up low byte of jump addr on stack
000601 034D E5F0                         mov     a,b
000602 034F 3583                         addc    a,dph
000603 0351 C0E0                         push    acc         ; set  up high byte of jump address on stack
000604 0353 22                           ret                 ; pop jump addr off stack & go to it
000605 0354 E580             monrdsft:   mov     A, 128 
000606 0356 22                           ret
000607 0357 E581                         mov     A, 129 
000608 0359 22                           ret
000609 035A E582                         mov     A, 130 
000610 035C 22                           ret
000611 035D E583                         mov     A, 131 
000612 035F 22                           ret
000613 0360 E584                         mov     A, 132 
000614 0362 22                           ret
000615 0363 E585                         mov     A, 133 
000616 0365 22                           ret
000617 0366 E586                         mov     A, 134 
000618 0368 22                           ret
000619 0369 E587                         mov     A, 135 
000620 036B 22                           ret
000621 036C E588                         mov     A, 136 
000622 036E 22                           ret
000623 036F E589                         mov     A, 137 
000624 0371 22                           ret
000625 0372 E58A                         mov     A, 138 
000626 0374 22                           ret
000627 0375 E58B                         mov     A, 139 
000628 0377 22                           ret
000629 0378 E58C                         mov     A, 140 
000630 037A 22                           ret
000631 037B E58D                         mov     A, 141 
000632 037D 22                           ret
000633 037E E58E                         mov     A, 142 
000634 0380 22                           ret
000635 0381 E58F                         mov     A, 143 
000636 0383 22                           ret
000637 0384 E590                         mov     A, 144 
000638 0386 22                           ret
000639 0387 E591                         mov     A, 145 
000640 0389 22                           ret
000641 038A E592                         mov     A, 146 
000642 038C 22                           ret
000643 038D E593                         mov     A, 147 
000644 038F 22                           ret
000645 0390 E594                         mov     A, 148 
000646 0392 22                           ret
000647 0393 E595                         mov     A, 149 
000648 0395 22                           ret
000649 0396 E596                         mov     A, 150 
000650 0398 22                           ret
000651 0399 E597                         mov     A, 151 
000652 039B 22                           ret
000653 039C E598                         mov     A, 152 
000654 039E 22                           ret
000655 039F E599                         mov     A, 153 
000656 03A1 22                           ret
000657 03A2 E59A                         mov     A, 154 
000658 03A4 22                           ret
000659 03A5 E59B                         mov     A, 155 
000660 03A7 22                           ret
000661 03A8 E59C                         mov     A, 156 
000662 03AA 22                           ret
000663 03AB E59D                         mov     A, 157 
000664 03AD 22                           ret
000665 03AE E59E                         mov     A, 158 
000666 03B0 22                           ret
000667 03B1 E59F                         mov     A, 159 
000668 03B3 22                           ret
000669 03B4 E5A0                         mov     A, 160 
000670 03B6 22                           ret
000671 03B7 E5A1                         mov     A, 161 
000672 03B9 22                           ret
000673 03BA E5A2                         mov     A, 162 
000674 03BC 22                           ret
000675 03BD E5A3                         mov     A, 163 
000676 03BF 22                           ret
000677 03C0 E5A4                         mov     A, 164 
000678 03C2 22                           ret
000679 03C3 E5A5                         mov     A, 165 
000680 03C5 22                           ret
000681 03C6 E5A6                         mov     A, 166 
000682 03C8 22                           ret
000683 03C9 E5A7                         mov     A, 167 
000684 03CB 22                           ret
000685 03CC E5A8                         mov     A, 168 
000686 03CE 22                           ret
000687 03CF E5A9                         mov     A, 169 
000688 03D1 22                           ret
000689 03D2 E5AA                         mov     A, 170 
000690 03D4 22                           ret
000691 03D5 E5AB                         mov     A, 171 
000692 03D7 22                           ret
000693 03D8 E5AC                         mov     A, 172 
000694 03DA 22                           ret
000695 03DB E5AD                         mov     A, 173 
000696 03DD 22                           ret
000697 03DE E5AE                         mov     A, 174 
000698 03E0 22                           ret
000699 03E1 E5AF                         mov     A, 175 
000700 03E3 22                           ret
000701 03E4 E5B0                         mov     A, 176 
000702 03E6 22                           ret
000703 03E7 E5B1                         mov     A, 177 
000704 03E9 22                           ret
000705 03EA E5B2                         mov     A, 178 
000706 03EC 22                           ret
000707 03ED E5B3                         mov     A, 179 
000708 03EF 22                           ret
000709 03F0 E5B4                         mov     A, 180 
000710 03F2 22                           ret
000711 03F3 E5B5                         mov     A, 181 
000712 03F5 22                           ret
000713 03F6 E5B6                         mov     A, 182 
000714 03F8 22                           ret
000715 03F9 E5B7                         mov     A, 183 
000716 03FB 22                           ret
000717 03FC E5B8                         mov     A, 184 
000718 03FE 22                           ret
000719 03FF E5B9                         mov     A, 185 
000720 0401 22                           ret
000721 0402 E5BA                         mov     A, 186 
000722 0404 22                           ret
000723 0405 E5BB                         mov     A, 187 
000724 0407 22                           ret
000725 0408 E5BC                         mov     A, 188 
000726 040A 22                           ret
000727 040B E5BD                         mov     A, 189 
000728 040D 22                           ret
000729 040E E5BE                         mov     A, 190 
000730 0410 22                           ret
000731 0411 E5BF                         mov     A, 191 
000732 0413 22                           ret
000733 0414 E5C0                         mov     A, 192 
000734 0416 22                           ret
000735 0417 E5C1                         mov     A, 193 
000736 0419 22                           ret
000737 041A E5C2                         mov     A, 194 
000738 041C 22                           ret
000739 041D E5C3                         mov     A, 195 
000740 041F 22                           ret
000741 0420 E5C4                         mov     A, 196 
000742 0422 22                           ret
000743 0423 E5C5                         mov     A, 197 
000744 0425 22                           ret
000745 0426 E5C6                         mov     A, 198 
000746 0428 22                           ret
000747 0429 E5C7                         mov     A, 199 
000748 042B 22                           ret
000749 042C E5C8                         mov     A, 200 
000750 042E 22                           ret
000751 042F E5C9                         mov     A, 201 
000752 0431 22                           ret
000753 0432 E5CA                         mov     A, 202 
000754 0434 22                           ret
000755 0435 E5CB                         mov     A, 203 
000756 0437 22                           ret
000757 0438 E5CC                         mov     A, 204 
000758 043A 22                           ret
000759 043B E5CD                         mov     A, 205 
000760 043D 22                           ret
000761 043E E5CE                         mov     A, 206 
000762 0440 22                           ret
000763 0441 E5CF                         mov     A, 207 
000764 0443 22                           ret
000765 0444 E5D0                         mov     A, 208 
000766 0446 22                           ret
000767 0447 E5D1                         mov     A, 209 
000768 0449 22                           ret
000769 044A E5D2                         mov     A, 210 
000770 044C 22                           ret
000771 044D E5D3                         mov     A, 211 
000772 044F 22                           ret
000773 0450 E5D4                         mov     A, 212 
000774 0452 22                           ret
000775 0453 E5D5                         mov     A, 213 
000776 0455 22                           ret
000777 0456 E5D6                         mov     A, 214 
000778 0458 22                           ret
000779 0459 E5D7                         mov     A, 215 
000780 045B 22                           ret
000781 045C E5D8                         mov     A, 216 
000782 045E 22                           ret
000783 045F E5D9                         mov     A, 217 
000784 0461 22                           ret
000785 0462 E5DA                         mov     A, 218 
000786 0464 22                           ret
000787 0465 E5DB                         mov     A, 219 
000788 0467 22                           ret
000789 0468 E5DC                         mov     A, 220 
000790 046A 22                           ret
000791 046B E5DD                         mov     A, 221 
000792 046D 22                           ret
000793 046E E5DE                         mov     A, 222 
000794 0470 22                           ret
000795 0471 E5DF                         mov     A, 223 
000796 0473 22                           ret
000797 0474 E5E0                         mov     A, 224 
000798 0476 22                           ret
000799 0477 E5E1                         mov     A, 225 
000800 0479 22                           ret
000801 047A E5E2                         mov     A, 226 
000802 047C 22                           ret
000803 047D E5E3                         mov     A, 227 
000804 047F 22                           ret
000805 0480 E5E4                         mov     A, 228 
000806 0482 22                           ret
000807 0483 E5E5                         mov     A, 229 
000808 0485 22                           ret
000809 0486 E5E6                         mov     A, 230 
000810 0488 22                           ret
000811 0489 E5E7                         mov     A, 231 
000812 048B 22                           ret
000813 048C E5E8                         mov     A, 232 
000814 048E 22                           ret
000815 048F E5E9                         mov     A, 233 
000816 0491 22                           ret
000817 0492 E5EA                         mov     A, 234 
000818 0494 22                           ret
000819 0495 E5EB                         mov     A, 235 
000820 0497 22                           ret
000821 0498 E5EC                         mov     A, 236 
000822 049A 22                           ret
000823 049B E5ED                         mov     A, 237 
000824 049D 22                           ret
000825 049E E5EE                         mov     A, 238 
000826 04A0 22                           ret
000827 04A1 E5EF                         mov     A, 239 
000828 04A3 22                           ret
000829 04A4 E5F0                         mov     A, 240 
000830 04A6 22                           ret
000831 04A7 E5F1                         mov     A, 241 
000832 04A9 22                           ret
000833 04AA E5F2                         mov     A, 242 
000834 04AC 22                           ret
000835 04AD E5F3                         mov     A, 243 
000836 04AF 22                           ret
000837 04B0 E5F4                         mov     A, 244 
000838 04B2 22                           ret
000839 04B3 E5F5                         mov     A, 245 
000840 04B5 22                           ret
000841 04B6 E5F6                         mov     A, 246 
000842 04B8 22                           ret
000843 04B9 E5F7                         mov     A, 247 
000844 04BB 22                           ret
000845 04BC E5F8                         mov     A, 248 
000846 04BE 22                           ret
000847 04BF E5F9                         mov     A, 249 
000848 04C1 22                           ret
000849 04C2 E5FA                         mov     A, 250 
000850 04C4 22                           ret
000851 04C5 E5FB                         mov     A, 251 
000852 04C7 22                           ret
000853 04C8 E5FC                         mov     A, 252 
000854 04CA 22                           ret
000855 04CB E5FD                         mov     A, 253 
000856 04CD 22                           ret
000857 04CE E5FE                         mov     A, 254 
000858 04D0 22                           ret
000859 04D1 E5FF                         mov     A, 255 
000860 04D3 22                           ret
000861 04D4                  
000862 04D4                  ;======================================================================
000863 04D4                  ; ihexin
000864 04D4                  ; Reads in intelhex directly into data memory.
000865 04D4                  ; Format of record is :LLAAAATTdCC
000866 04D4                  ; where:
000867 04D4                  ; LL is the length of the data section (d) 
000868 04D4                  ; AAAA is the load address
000869 04D4                  ; TT is the record type (00 for data, 01 for end of file)
000870 04D4                  ; d is the data section containing LL bytes
000871 04D4                  ; CC is the checksum (all the bytes in the record, including the checksum
000872 04D4                  ;                     should sum to 0)
000873 04D4                  ; Parameters:   NONE
000874 04D4                  ; Returns:      NOTHING
000875 04D4                  ; Uses:         A - scratch
000876 04D4                  ;               B - scratch
000877 04D4                  ;               DPTR - load address
000878 04D4                  ;               R0 - byte counter
000879 04D4                  ;               R1 - checksum
000880 04D4                  ;======================================================================
000881 04D4 D1A6             ihexin:     acall   scomrxa         ; read initial :
000882 04D6 B43A50           ihexinlp:   cjne    A,#':', ihexf1  ; fail if not
000883 04D9                  
000884 04D9 75992E                       mov     sbuf,#'.'       ; transmit confidence dot
000885 04DC                  
000886 04DC                              ; get record length & include in checksum
000887 04DC D1AE                         acall   scomrhx8        ; read record length into A
000888 04DE 404E                         jc      ihexf2          ; invalid hex if carry set
000889 04E0 F8                           mov     r0,A            ; use R0 as byte counter
000890 04E1 F9                           mov     r1,A            ; zero checksum + first byte
000891 04E2                              
000892 04E2 C299                         clr     scon.1          ; reset TI - char must have been transmitted
000893 04E4                                                      ; as we've read 2 chars since sbuf set
000894 04E4                  
000895 04E4                              ; get load address in dptr & include in checksum
000896 04E4 D1CB                         acall   scomrh16        ; load address -> dptr
000897 04E6 4046                         jc      ihexf2          ; invalid hex if carry set
000898 04E8 E9                           mov     a,r1            ; get checksum
000899 04E9 2583                         add     a,dph           ; to include load address high byte
000900 04EB 2582                         add     a,dpl           ; and load address low byte
000901 04ED F9                           mov     r1,a            ; save again
000902 04EE                              
000903 04EE                              ; record type: 00 is data, 01 is end
000904 04EE D1AE                         acall   scomrhx8        ; read record type
000905 04F0 403C                         jc      ihexf2          ; invalid hex if carry set
000906 04F2 B4010A                       cjne    a,#1,ihexdata   ; 1 marks end record
000907 04F5                  
000908 04F5                              ; if record type was 1 then end record so finish:
000909 04F5 D1AE                         acall   scomrhx8        ; read checksum byte & discard
000910 04F7 4035                         jc      ihexf2          ; invalid hex if carry set
000911 04F9 900533                       mov     dptr,#ihexokm   ; ok message
000912 04FC B1E8                         acall   scomtxc         ; & print it
000913 04FE 22                           ret                     ; end of routine
000914 04FF                  
000915 04FF 29               ihexdata:   add     a,r1            ; include record type byte in checksum
000916 0500 F9                           mov     r1,a
000917 0501                  
000918 0501                  ; -- loop getting data
000919 0501 E8               ihexlp:     mov     a,r0            ; get count
000920 0502 600B                         jz      ihexerec        ; end of record if done
000921 0504                  
000922 0504 D1AE                         acall   scomrhx8        ; read data byte
000923 0506 4026                         jc      ihexf2          ; invalid hex if carry set
000924 0508 F0                           movx    @dptr,a         ; stuff it at current load address
000925 0509 A3                           inc     dptr
000926 050A 29                           add     a,r1            ; include in checksum
000927 050B F9                           mov     r1,a
000928 050C                  
000929 050C 18                           dec     r0              ; decrement byte count
000930 050D 80F2                         sjmp    ihexlp          ; and get next data byte
000931 050F                  
000932 050F                  
000933 050F                  ihexerec:   ; -- end of record, read in & check checksum
000934 050F D1AE                         acall   scomrhx8        ; read checksum byte
000935 0511 401B                         jc      ihexf2          ; invalid hex if carry set
000936 0513 29                           add     a,r1            ; include in total
000937 0514 6005                         jz      ihexok          ; should sum to 0 if 0K
000938 0516 90058F                       mov     dptr,#ihexf3m   ; checksum mismatch message
000939 0519 A1E8                         ajmp    scomtxc         ; print & return
000940 051B                  
000941 051B                  
000942 051B                  ihexok:     ; -- the complete record has been read in 
000943 051B                              ; -- skip any cr-lf combination on the end
000944 051B D1A6                         acall   scomrxa         ; get next char from input
000945 051D B40D02                       cjne    a,#13,ihexncr   ; is it a cr?
000946 0520 80F9                         sjmp    ihexok          ; ignore & look for next char if so
000947 0522 B40A02           ihexncr:    cjne    a,#10,ihexnlf   ; is it a lf?
000948 0525 80F4                         sjmp    ihexok          ; ignore & look for next char if so
000949 0527 80AD             ihexnlf:    sjmp    ihexinlp        ; not a cr or lf so loop back for next record
000950 0529                  
000951 0529 900544           ihexf1:     mov     dptr,#ihexf1m   ; missing :
000952 052C A1E8                         ajmp    scomtxc         ; print and return
000953 052E 90056D           ihexf2:     mov     dptr,#ihexf2m   ; invalid hex 
000954 0531 A1E8                         ajmp    scomtxc         ; print and return
000955 0533 50726F6772616D20 ihexokm:    .db   "Program loaded\r\n\0"
       053B 6C6F616465640D0A
       0543 00              
000956 0544 4D697373696E6720 ihexf1m:    .db   "Missing : at start of Intel-hex record\r\n\0"
       054C 3A20617420737461
       0554 7274206F6620496E
       055C 74656C2D68657820
       0564 7265636F72640D0A
       056C 00              
000957 056D 496E76616C696420 ihexf2m:    .db   "Invalid hex in Intel-hex upload\r\n\0"
       0575 68657820696E2049
       057D 6E74656C2D686578
       0585 2075706C6F61640D
       058D 0A00            
000958 058F 496E74656C2D6865 ihexf3m:    .db   "Intel-hex checksum mis-match\r\n\0"
       0597 7820636865636B73
       059F 756D206D69732D6D
       05A7 617463680D0A00  
000959 05AE                  
000960 05AE                  
000961 05AE                  ;======================================================================
000962 05AE                  ; vjump
000963 05AE                  ; vectored jump - gets jump address from serial port & jumps to it
000964 05AE                  ; called routine should terminate with a ret (this is called from
000965 05AE                  ; the monitor vector which already has pushed a return addr)
000966 05AE                  ; Parameters:   NONE
000967 05AE                  ; Returns:      NOTHING
000968 05AE                  ;======================================================================
000969 05AE D1CB             vjump:      acall   scomrh16        ; jump address -> dptr
000970 05B0 C082                         push    dpl             ; save jump address
000971 05B2 C083                         push    dph
000972 05B4                  
000973 05B4 9005BA                       mov     dptr,#vjumpmsg
000974 05B7 B1E8                         acall   scomtxc
000975 05B9                  
000976 05B9 22                           ret                     ; jump to pushed address
000977 05BA 204A756D700D0A00 vjumpmsg:   .db " Jump\r\n\0"       
000978 05C2                  
000979 05C2                  ;======================================================================
000980 05C2                  ; echo
000981 05C2                  ; echoes characters back to host until a . is received (test routine)
000982 05C2                  ;======================================================================
000983 05C2 D1A6             echo:       acall   scomrxa     ; get a char
000984 05C4 B1E0                         acall   scomtxa     ; echo it
000985 05C6 B42EF9                       cjne    a,#'.',echo ; loop if not "."
000986 05C9 22                           ret
000987 05CA                  
000988 05CA                  ;======================================================================
000989 05CA                  ;======================================================================
000990 05CA                  ; Support routines
000991 05CA                  ;======================================================================
000992 05CA                  ;======================================================================
000993 05CA                  
000994 05CA                  ;======================================================================
000995 05CA                  ; scominit
000996 05CA                  ; Initialises the serial port to transmit/receive data at 19200 baud
000997 05CA                  ; assuming an 11.059MHz crystal.
000998 05CA                  ; Parameters:   NONE
000999 05CA                  ; Returns:      NOTHING
001000 05CA                  ;======================================================================
001001 05CA 53890F           scominit:   anl     tmod,#0fh   ; clear t1 control bits
001002 05CD 438920                       orl     tmod,#20h   ; set t1 for mode 2 (auto reload)
001003 05D0 758DFD                       mov     th1,#253    ; 9600 baud for11.059MHz clock
001004 05D3 D28E                         setb    tr1         ; TCON.6 - run timer 1
001005 05D5 438780                       orl     pcon,#80h   ; set SMOD - 2x baud ->19200
001006 05D8 759850                       mov     scon,#50h   ; 8 bit UART, receive enabled
001007 05DB C299                         clr     ti          
001008 05DD C298                         clr     ri
001009 05DF 22                           ret
001010 05E0                  
001011 05E0                  ;======================================================================
001012 05E0                  ; scomtxa
001013 05E0                  ; Transmits the character in A
001014 05E0                  ; Parameters:   char to transmit in A
001015 05E0                  ; Returns:      NOTHING
001016 05E0                  ;======================================================================
001017 05E0 F599             scomtxa:    mov     sbuf,a      ; transmit a
001018 05E2 3099FD           scomtxw:    jnb     scon.1, scomtxw ; wait until char transmitted
001019 05E5 C299                         clr     scon.1      ; reset TI before next char
001020 05E7 22                           ret
001021 05E8                  
001022 05E8                  ;======================================================================
001023 05E8                  ; scomtxc
001024 05E8                  ; Transmits the zero terminated string, from code memory, pointed
001025 05E8                  ; to by DPTR
001026 05E8                  ; Parameters:   Pointer to code string in DPTR
001027 05E8                  ; Returns:      NOTHING
001028 05E8                  ; Modifies:     A, DPTR
001029 05E8                  ;======================================================================
001030 05E8 E4               scomtxc:    clr     a           ; zero offset
001031 05E9 93                           movc    a,@a+dptr
001032 05EA 6005                         jz      scomcz      ; 0 byte for end of string
001033 05EC B1E0                         acall    scomtxa    ; transmit char
001034 05EE A3                           inc     dptr
001035 05EF 80F7                         sjmp    scomtxc     ; next char
001036 05F1 22               scomcz:     ret
001037 05F2                  
001038 05F2                  ;======================================================================
001039 05F2                  ; scomtxx
001040 05F2                  ; Transmits the zero terminated string, from data memory, pointed
001041 05F2                  ; to by DPTR
001042 05F2                  ; Parameters:   Pointer to code string in DPTR
001043 05F2                  ; Returns:      NOTHING
001044 05F2                  ; Modifies:     A, DPTR
001045 05F2                  ;======================================================================
001046 05F2 E0               scomtxx:    movx    a,@dptr
001047 05F3 6005                         jz      scomcxz     ; 0 byte for end of string
001048 05F5 B1E0                         acall    scomtxa    ; transmit char
001049 05F7 A3                           inc     dptr
001050 05F8 80F8                         sjmp    scomtxx     ; next char
001051 05FA 22               scomcxz:    ret
001052 05FB                  
001053 05FB                  ;======================================================================
001054 05FB                  ; scomtx8
001055 05FB                  ; Transmits A as 2 hex digits
001056 05FB                  ; Parameters:   byte to transmit in A
001057 05FB                  ; Returns:      NOTHING
001058 05FB                  ; Modifies:     A,B,DPTR
001059 05FB                  ;======================================================================
001060 05FB F5F0             scomtx8:    mov     b,a         ; save for low byte
001061 05FD C4                           swap    a           ; get ms nibble -> ls
001062 05FE 540F                         anl     a,#15       ; zero high nibble
001063 0600 D10D                         acall   scomhcon    ; convert to hex
001064 0602 B1E0                         acall   scomtxa     ; and send it
001065 0604 E5F0                         mov     a,b         ; get ls nibble saved earlier
001066 0606 540F                         anl     a,#15       ; zero high nibble
001067 0608 D10D                         acall   scomhcon    ; convert to hex
001068 060A B1E0                         acall   scomtxa     ; and send it
001069 060C 22                           ret
001070 060D 04               scomhcon:   inc     a           ; need to allow 1 byte for ret
001071 060E 83                           movc    a,@a+pc     ; look up to convert binary to hex digit
001072 060F 22                           ret
001073 0610 3031323334353637 scomhtab:   .db "0123456789ABCDEF"
       0618 3839414243444546
001074 0620                  
001075 0620                  ;======================================================================
001076 0620                  ; scomcnib
001077 0620                  ; Translates a hex digit to its binary equivalent.  Note that the 
001078 0620                  ; lookup table in code memory must be the correct number of bytes 
001079 0620                  ; away from this routine if this is to work. Note that with the sparse
001080 0620                  ; look up table the other serial recieve routines are placed between
001081 0620                  ; this routine & the start of the lookup table ('0') 47 bytes further
001082 0620                  ; on.
001083 0620                  ; Parameters:   Hex digit in A
001084 0620                  ; Returns:      Translated byte in A, 255 if invalid hex
001085 0620                  ; Modifies:     A
001086 0620                  ; Bytes:        2
001087 0620                  ;======================================================================
001088 0620 547F             scomcnib:   anl     a,#127      ; force to 7 bit ascii
001089 0622 05E0                         inc     acc         ; allow for ret
001090 0624 83                           movc    a,@a+pc     ; (1,2) convert ascii to hex nibble via lookup table
001091 0625 22                           ret                 ; (1,2)
001092 0626 FFFFFFFFFFFFFFFF .db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
       062E FFFFFFFFFFFFFFFF
001093 0636 FFFFFFFFFFFFFFFF .db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
       063E FFFFFFFFFFFFFFFF
001094 0646 FFFFFFFFFFFFFFFF .db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
       064E FFFFFFFFFFFFFFFF
001095 0656 0001020304050607 .db 0,1,2,3,4,5,6,7,8,9,255,255,255,255,255,255
       065E 0809FFFFFFFFFFFF
001096 0666 FF0A0B0C0D0E0FFF .db 255,10,11,12,13,14,15,255,255,255,255,255,255,255,255,255
       066E FFFFFFFFFFFFFFFF
001097 0676 FFFFFFFFFFFFFFFF .db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
       067E FFFFFFFFFFFFFFFF
001098 0686 FF0A0B0C0D0E0FFF .db 255,10,11,12,13,14,15,255,255,255,255,255,255,255,255,255
       068E FFFFFFFFFFFFFFFF
001099 0696 FFFFFFFFFFFFFFFF .db 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
       069E FFFFFFFFFFFFFFFF
001100 06A6                  
001101 06A6                  ;======================================================================
001102 06A6                  ; scomrxa
001103 06A6                  ; Waits for, and reads the next byte from the serial port
001104 06A6                  ; Parameters:   NONE
001105 06A6                  ; Returns:      The received byte in A
001106 06A6                  ; Modifies:     A
001107 06A6                  ; Bytes:        8
001108 06A6                  ;======================================================================
001109 06A6 3098FD           scomrxa:    jnb     RI,scomrxa  ; (3,2) wait for char present
001110 06A9 E599                         mov     A,SBUF      ; (2,1) read from serial buffer
001111 06AB C298                         clr     RI          ; (2,1)
001112 06AD 22                           ret                 ; (1,2)
001113 06AE                  
001114 06AE                  ;======================================================================
001115 06AE                  ; scomrhx8
001116 06AE                  ; Waits for, and reads a hex encoded byte (2 hex digits) from the
001117 06AE                  ; serial port
001118 06AE                  ; Parameters:   NONE
001119 06AE                  ; Returns:      The received byte in A.  C is set if invalid hex
001120 06AE                  ; Modifies:     A,B 
001121 06AE                  ; Bytes:        
001122 06AE                  ;======================================================================
001123 06AE D1A6             scomrhx8:   acall   scomrxa             ; read a char into A
001124 06B0 D120                         acall   scomcnib            ; convert hex nibble to binary
001125 06B2 B4FF02                       cjne    a,#255,scomh8o1     ; ok if not equal to error value
001126 06B5 8010                         sjmp    scomh8fl            ; error 
001127 06B7 C4               scomh8o1:   swap    a                   ; move digit to high nibble
001128 06B8 F5F0                         mov     b,a                 ; temp store in b while next char read
001129 06BA D1A6                         acall   scomrxa             ; read a char into A
001130 06BC D120                         acall   scomcnib            ; convert hex nibble to binary
001131 06BE B4FF02                       cjne    a,#255,scomh8o2     ; ok if not equal to error value
001132 06C1 8004                         sjmp    scomh8fl            ; error 
001133 06C3 45F0             scomh8o2:   orl     a,b                 ; fold in ms nibble
001134 06C5 C3                           clr     c                   ; ok.
001135 06C6 22                           ret                         ; 
001136 06C7 7400             scomh8fl:   mov     a,#0                ; return 0 on error
001137 06C9 D3                           setb    c                   ; report failure
001138 06CA 22                           ret
001139 06CB                  
001140 06CB                  ;======================================================================
001141 06CB                  ; scomrh16
001142 06CB                  ; Waits for, and reads a hex encoded word (4 hex digits) from the
001143 06CB                  ; serial port
001144 06CB                  ; Parameters:   NONE
001145 06CB                  ; Returns:      The received word in DPTR, C set if error, clear if ok
001146 06CB                  ; Modifies:     A,B,DPTR 
001147 06CB                  ; Bytes:        
001148 06CB                  ;======================================================================
001149 06CB D1AE             scomrh16:   acall   scomrhx8    ; ms 2 hex digits -> A
001150 06CD 400A                         jc      scomr16f    ; fail if carry set
001151 06CF F583                         mov     dph,a       ; 
001152 06D1 D1AE                         acall   scomrhx8    ; ls 2 hex digits -> A
001153 06D3 4004                         jc      scomr16f    ; fail if carry set
001154 06D5 F582                         mov     dpl,a       ; 
001155 06D7 C3                           clr     c           ; signal success
001156 06D8 22                           ret                 ; 
001157 06D9 758300           scomr16f:   mov     dph,#0
001158 06DC 758200                       mov     dpl,#0
001159 06DF 22                           ret                 ; with carry set
001160 06E0                  
001161 06E0                  
001162 06E0                  ;**********************************************************************
001163 06E0                  ; Timer 0 routines to provide timing services.
001164 06E0                  ;**********************************************************************
001165 06E0                  
001166 06E0                  ;======================================================================
001167 06E0                  ; timinit
001168 06E0                  ; routine to set up the T0 timer inerrupt.
001169 06E0                  ; TODO- figure out timer values for c. 100Hz on 11.059MHz crystal
001170 06E0                  ;======================================================================
001171 06E0 C290             timinit:    clr     P1.0            ; start with space
001172 06E2 5389F0                       anl     tmod,#0F0h      ; clear timer 0 bits
001173 06E5 438901                       orl     tmod,#001h      ; set up timer 0 to mode 1, free run
001174 06E8 758AE0                       mov     tl0,#0E0h       ; setup timer for c. 50Hz
001175 06EB 758CB1                       mov     th0,#0B1h       
001176 06EE D2A9                         setb    et0             ; enable timer 0 overflow interrupt
001177 06F0 D2AF                         setb    ea              ; global interrupt enable
001178 06F2 D28C                         setb    tcon.4          ; run timer            
001179 06F4 22                           ret
001180 06F5                  
001181 06F5                  
001182 06F5                  ;======================================================================
001183 06F5                  ; timeint
001184 06F5                  ; main timer interrupt routine, called from vector proper.  Provides
001185 06F5                  ; downcounter in countdn variable and also calls any vectored routine
001186 06F5                  ; via tickvect
001187 06F5                  ;======================================================================
001188 06F5                  timeint:
001189 06F5 C0D0                         push    psw
001190 06F7 C0E0                         push    acc
001191 06F9 C0F0                         push    b
001192 06FB                  
001193 06FB C28C                         clr     tcon.4          ; stop timer
001194 06FD 758AE0                       mov     tl0,#0E0h       ; setup timer for space
001195 0700 758CB1                       mov     th0,#0B1h       
001196 0703 C290                         clr     P1.0
001197 0705 D28C                         setb    tcon.4          ; run timer
001198 0707                  
001199 0707                              ; now time is running - get on with housekeeping tasks
001200 0707                              ; that are driven by timer tick
001201 0707                  
001202 0707                              ; will need these later...
001203 0707 C083                         push dph
001204 0709 C082                         push dpl
001205 070B                  
001206 070B                              ; dec countdown timer if non-zero
001207 070B E522                         mov     a,countdn
001208 070D 6002                         jz      dochain
001209 070F 1522                         dec     countdn         ; dec countdown timer
001210 0711                  
001211 0711                  
001212 0711                  dochain:    ; see if there is a chain vector
001213 0711 E523                         mov a,tickvect
001214 0713 4524                         orl a,tickvect+1
001215 0715 600F                         jz servdone             ; skip if no chain vector
001216 0717                              
001217 0717                              ; If there is a chain vector, simulate indirect call
001218 0717 900726                       mov dptr,#servdone      ; fix up a return addr
001219 071A C082                         push dpl                ; on stack to simulate call
001220 071C C083                         push dph
001221 071E 852382                       mov dpl,tickvect        ; get call vector
001222 0721 852483                       mov dph,tickvect+1
001223 0724 E4                           clr a
001224 0725 73                           jmp @a+dptr             ; go - called routine should use ret
001225 0726                  
001226 0726                  ; -- Restore & return
001227 0726 D082             servdone:   pop dpl
001228 0728 D083                         pop dph
001229 072A D0F0                         pop     b
001230 072C D0E0                         pop     acc
001231 072E D0D0                         pop     psw
001232 0730 32                           reti
001233 0731                  
001234 0731                  
001235 0731                  
001236 0731                  ;======================================================================
001237 0731                  ; settim
001238 0731                  ; sets the timeout value
001239 0731                  ;======================================================================
001240 0731 F522             settim:     mov countdn,A
001241 0733 22                           ret
001242 0734                  
001243 0734                  ;======================================================================
001244 0734                  ; timer
001245 0734                  ; reads the timer value
001246 0734                  ;======================================================================
001247 0734 E522             timer:      mov A,countdn
001248 0736 22                           ret
001249 0737                  
001250 0737                  ;======================================================================
001251 0737                  ; tkchain
001252 0737                  ; chains the tick value
001253 0737                  ; new value in dptr, returns old value in dptr
001254 0737                  ;======================================================================
001255 0737 A2AF             tkchain:    mov   C,ea              ; get old global interrupt enable
001256 0739 C2AF                         clr   ea                ; disable interrupts
001257 073B E523                         mov   A,tickvect        ; swap tickvect with dptr
001258 073D 858223                       mov   tickvect,dpl
001259 0740 F582                         mov   dpl,A
001260 0742 E524                         mov   A,tickvect+1
001261 0744 858324                       mov   tickvect+1,dph
001262 0747 F583                         mov   dph,A
001263 0749 92AF                         mov   ea,C              ; restore global interrupt enable
001264 074B 22                           ret
001265 074C                  
001266 074C                  
001267 074C                  
001268 074C                  ;**********************************************************************
001269 074C                  ; I2C routines.  2 channels of I2C implemented called A and B.
001270 074C                  ;**********************************************************************
001271 074C                  
001272 074C                  ;======================================================================
001273 074C                  ; I2C Start routine for I2c channel A
001274 074C                  ;======================================================================
001275 074C D2B3             i2csta:     setb sda_a
001276 074E 00                           nop
001277 074F 00                           nop
001278 0750 00                           nop
001279 0751 00                           nop
001280 0752 D2B2                         setb scl_a
001281 0754 00                           nop
001282 0755 00                           nop
001283 0756 00                           nop
001284 0757 00                           nop
001285 0758 C2B3                         clr sda_a
001286 075A 00                           nop
001287 075B 00                           nop
001288 075C 00                           nop
001289 075D 00                           nop
001290 075E C2B2                         clr scl_a
001291 0760 00                           nop
001292 0761 00                           nop
001293 0762 00                           nop
001294 0763 22                           ret
001295 0764                  
001296 0764                  
001297 0764                  ;======================================================================
001298 0764                  ; I2C Stop routine for I2C channel A
001299 0764                  ;======================================================================
001300 0764 C2B3             i2cspa:     clr sda_a
001301 0766 00                           nop
001302 0767 00                           nop
001303 0768 00                           nop
001304 0769 00                           nop
001305 076A D2B2                         setb scl_a
001306 076C 00                           nop
001307 076D 00                           nop
001308 076E 00                           nop
001309 076F 00                           nop
001310 0770 D2B3                         setb sda_a
001311 0772 00                           nop
001312 0773 00                           nop
001313 0774 00                           nop
001314 0775 22                           ret
001315 0776                  
001316 0776                  ;======================================================================
001317 0776                  ; I2C transmit for I2C channel A.  Byte in A
001318 0776                  ; returns ~ACK in C
001319 0776                  ; uses R0
001320 0776                  ;======================================================================
001321 0776 7808             i2ctxa:     mov r0,#8
001322 0778 33               i2atx1:     rlc a				; msb -> A
001323 0779 92B3                         mov sda_a,c
001324 077B D2B2                         setb scl_a
001325 077D 00                           nop
001326 077E 00                           nop
001327 077F 00                           nop
001328 0780 00                           nop
001329 0781 C2B2                         clr scl_a
001330 0783 00                           nop
001331 0784 D8F2                         djnz r0,i2atx1
001332 0786 00                           nop
001333 0787 00                           nop
001334 0788 D2B3                         setb sda_a
001335 078A D2B2                         setb scl_a
001336 078C 00                           nop
001337 078D 00                           nop
001338 078E 00                           nop
001339 078F A2B3                         mov c,sda_a			; get ack bit, low is ACK, high NACK
001340 0791 C2B2                         clr scl_a
001341 0793 22                           ret
001342 0794                  
001343 0794                  ;======================================================================
001344 0794                  ; I2C receive for channel A.  Ack flag in C, returns byte in A
001345 0794                  ; uses R0
001346 0794                  ;======================================================================
001347 0794 D2B3             i2crxa:     setb sda_a			; make sure data released
001348 0796 7808                         mov r0, #8
001349 0798 33               i2arx1:     rlc a
001350 0799 D2B2                         setb scl_a
001351 079B 30B2FD           i2arx2:     jnb scl_a,i2arx2		; clock stretch from slave?
001352 079E 00                           nop
001353 079F 00                           nop
001354 07A0 A2B3                         mov c,sda_a
001355 07A2 C2B2                         clr scl_a
001356 07A4 00                           nop
001357 07A5 00                           nop
001358 07A6 D8F0                         djnz r0,i2arx1
001359 07A8 33                           rlc a			; last bit to acc & ack to C
001360 07A9 92B3                         mov sda_a,c
001361 07AB D2B2                         setb scl_a
001362 07AD 00                           nop
001363 07AE 00                           nop
001364 07AF 00                           nop
001365 07B0 00                           nop
001366 07B1 C2B2                         clr scl_a
001367 07B3 D2B3                         setb sda_a
001368 07B5 22                           ret
001369 07B6                  
001370 07B6                  
001371 07B6                  ;======================================================================
001372 07B6                  ; I2C Start routine for I2c channel B
001373 07B6                  ;======================================================================
001374 07B6 D2B5             i2cstb:     setb sda_b
001375 07B8 00                           nop
001376 07B9 00                           nop
001377 07BA 00                           nop
001378 07BB 00                           nop
001379 07BC D2B4                         setb scl_b
001380 07BE 00                           nop
001381 07BF 00                           nop
001382 07C0 00                           nop
001383 07C1 00                           nop
001384 07C2 C2B5                         clr sda_b
001385 07C4 00                           nop
001386 07C5 00                           nop
001387 07C6 00                           nop
001388 07C7 00                           nop
001389 07C8 C2B4                         clr scl_b
001390 07CA 00                           nop
001391 07CB 00                           nop
001392 07CC 00                           nop
001393 07CD 22                           ret
001394 07CE                  
001395 07CE                  
001396 07CE                  ;======================================================================
001397 07CE                  ; I2C Stop routine for I2C channel B
001398 07CE                  ;======================================================================
001399 07CE C2B5             i2cspb:     clr sda_b
001400 07D0 00                           nop
001401 07D1 00                           nop
001402 07D2 00                           nop
001403 07D3 00                           nop
001404 07D4 D2B4                         setb scl_b
001405 07D6 00                           nop
001406 07D7 00                           nop
001407 07D8 00                           nop
001408 07D9 00                           nop
001409 07DA D2B5                         setb sda_b
001410 07DC 00                           nop
001411 07DD 00                           nop
001412 07DE 00                           nop
001413 07DF 22                           ret
001414 07E0                  
001415 07E0                  ;======================================================================
001416 07E0                  ; I2C transmit for I2C channel B.  Byte in A
001417 07E0                  ; returns ~ACK in C
001418 07E0                  ; uses R0
001419 07E0                  ;======================================================================
001420 07E0 7808             i2ctxb:     mov r0,#8
001421 07E2 33               i2btx1:     rlc a				; msb -> A
001422 07E3 92B5                         mov sda_b,c
001423 07E5 D2B4                         setb scl_b
001424 07E7 00                           nop
001425 07E8 00                           nop
001426 07E9 00                           nop
001427 07EA 00                           nop
001428 07EB C2B4                         clr scl_b
001429 07ED 00                           nop
001430 07EE D888                         djnz r0,i2atx1
001431 07F0 00                           nop
001432 07F1 00                           nop
001433 07F2 D2B5                         setb sda_b
001434 07F4 D2B4                         setb scl_b
001435 07F6 00                           nop
001436 07F7 00                           nop
001437 07F8 00                           nop
001438 07F9 A2B5                         mov c,sda_b			; get ack bit, low is ACK, high NACK
001439 07FB C2B4                         clr scl_b
001440 07FD 22                           ret
001441 07FE                  
001442 07FE                  ;======================================================================
001443 07FE                  ; I2C receive for channel B.  Ack flag in C, returns byte in A
001444 07FE                  ; uses R0
001445 07FE                  ;======================================================================
001446 07FE D2B5             i2crxb:     setb sda_b			; make sure data released
001447 0800 7808                         mov r0, #8
001448 0802 33               i2brx1:     rlc a
001449 0803 D2B4                         setb scl_b
001450 0805 30B4FD           i2brx2:     jnb scl_b,i2brx2		; clock stretch from slave?
001451 0808 00                           nop
001452 0809 00                           nop
001453 080A A2B5                         mov c,sda_b
001454 080C C2B4                         clr scl_b
001455 080E 00                           nop
001456 080F 00                           nop
001457 0810 D8F0                         djnz r0,i2brx1
001458 0812 33                           rlc a			; last bit to acc & ack to C
001459 0813 92B5                         mov sda_b,c
001460 0815 D2B4                         setb scl_b
001461 0817 00                           nop
001462 0818 00                           nop
001463 0819 00                           nop
001464 081A 00                           nop
001465 081B C2B4                         clr scl_b
001466 081D D2B5                         setb sda_b
001467 081F 22                           ret
001468 0820                  
001469 0820                  
001470 0820                  
001471 0820                  ;======================================================================
001472 0820                  ; Jump table into useful monitor routines.  This isolates other code
001473 0820                  ; from changes in the monitor routines by providing a fixed vector table
001474 0820                  ; into those routines
001475 0820                  ;======================================================================
001476 0F00                              .org 1000h - 100h  ; allow 256 bytes jump table at top of bottom 4k
001477 0F00 02012A                       ljmp stop          ; stop execution
001478 0F03 0205CA                       ljmp scominit      ; intitialise serial port
001479 0F06 0205E0                       ljmp scomtxa       ; transmit ascii char in A
001480 0F09 0205E8                       ljmp scomtxc       ; transmit string from code mem ptr to by dptr
001481 0F0C 0205F2                       ljmp scomtxx       ; transmit string from ext mem ptr to by dptr
001482 0F0F 0205FB                       ljmp scomtx8       ; transmit byte in A as 2 hex digits
001483 0F12 0206A6                       ljmp scomrxa       ; receive an ascii char in A
001484 0F15 0206AE                       ljmp scomrhx8      ; receive a hex encoded byte into A
001485 0F18 0206CB                       ljmp scomrh16      ; receive a hex encoded word into dptr
001486 0F1B 0204D4                       ljmp ihexin        ; read intelhex file into data memory
001487 0F1E 020731                       ljmp settim        ; setup timer - value in A
001488 0F21 020734                       ljmp timer         ; get timer count - return value in A
001489 0F24 020737                       ljmp tkchain       ; chain tick count interrupt (dptr in, dptr out)
001490 0F27 02074C                       ljmp i2csta        ; I2C channel A - start
001491 0F2A 020764                       ljmp i2cspa        ; I2C channel A - stop
001492 0F2D 020776                       ljmp i2ctxa        ; I2C channel A - transmit A
001493 0F30 020794                       ljmp i2crxa        ; I2C channel A - receive to A
001494 0F33 0207B6                       ljmp i2cstb        ; I2C channel B - start
001495 0F36 0207CE                       ljmp i2cspb        ; I2C channel B - stop
001496 0F39 0207E0                       ljmp i2ctxb        ; I2C channel B - transmit A
001497 0F3C 0207FE                       ljmp i2crxb        ; I2C channel B - receive to A
001498 0F3F                  
001499 0F3F                  
001500 0F3F                  
001501 0F3F                   ;********************* ROBOT VIRTUAL MACHINE **********************
001502 1000                              .org  1000h                 ; 3rd 2k page
001503 1000                  ;======================================================================
001504 1000                  ; Robot Virtual Machine
001505 1000                  ;======================================================================
001506 1000                  
001507 1000                  ;======================================================================
001508 1000                  ; Virtual machine fault codes
001509 1000                  ; These are the predefined ones..
001510 1000                  ;======================================================================
001511 0000                              .equ vNone,0                ; no fault
001512 0001                              .equ vHalt,1                ; halt fault
001513 0002                              .equ vIlleg,2               ; illegal instruction fault
001514 0003                              .equ vBound,3               ; bounds fault
001515 0004                              .equ vESUnd,4               ; eval stack underflow
001516 0005                              .equ vESOvf,5               ; eval stack overflow
001517 0006                              .equ vRSUnd,6               ; return stack underflow
001518 0007                              .equ vRSOvf,7               ; return stack overflow
001519 1000                  
001520 1000                  ;======================================================================
001521 1000                  ; *** CODE ***
001522 1000                  ;======================================================================
001523 1000                  
001524 1000                  ;======================================================================
001525 1000                  ; vminit
001526 1000                  ; Initialises the virtual machine
001527 1000                  ;   initialise the basic VM
001528 1000                  ;   set up the event list
001529 1000                  ;======================================================================
001530 1000 75E000           vminit:     mov acc,#0 					; set up basic RSP position in vmrstk
001531 1003 85E034           			mov vmrstk, acc				; LSB
001532 1006 85E035           			mov vmrstk+1, acc			; MSB
001533 1009 8000                         sjmp vmreset
001534 100B                  
001535 100B                  ;======================================================================
001536 100B                  ; vmreset
001537 100B                  ; Resets the virtual machine
001538 100B                  ; Reset ESP
001539 100B                  ; Reset RSP
001540 100B                  ; Reset IP to 0 (invalid)
001541 100B                  ;======================================================================
001542 100B 753300           vmreset:    mov vmFltc,#vNone           ; reset fault code
001543 100E C200                         clr  vmfStop                ; reset stopped bit
001544 1010 793E                         mov R1,#(vmestk-2)          ; reset evaluation stack (-2 for preinc)
001545 1012 AC34                         mov R4,vmrstk               ; reset return stack LSB
001546 1014 AD35                         mov R5,vmrstk+1             ; reset return stack MSB
001547 1016 7E00                         mov R6,#0                   ; zero IP LSB
001548 1018 7F00                         mov R7,#0                   ; zero IP MSB
001549 101A 22                           ret
001550 101B                  
001551 101B                  ;======================================================================
001552 101B                  ; vmstart
001553 101B                  ; Starts up the virtual machine - vm is reset and then its IP is set
001554 101B                  ; to the start address pointed to by DPTR
001555 101B                  ;======================================================================
001556 101B 110B             vmstart:    acall vmreset
001557 101D AE82                         mov R6,dpl
001558 101F AF83                         mov R7,dph
001559 1021 22                           ret
001560 1022                  
001561 1022                  ;======================================================================
001562 1022                  ; vmrun
001563 1022                  ; Runs the vm until it hits a terminate instruction.
001564 1022                  ; VM must have had its IP set up by call to vmstart before hand
001565 1022                  ;======================================================================
001566 1022 200004           vmrun:      jb vmfStop,vmrune         ; abort if stopped bit is set
001567 1025 1139                         acall vmdisp              ; single tick
001568 1027 80F9                         sjmp vmrun                ; and do next instruction
001569 1029 22               vmrune:     ret
001570 102A                  
001571 102A                  ;======================================================================
001572 102A                  ; vmidle
001573 102A                  ; Determines whether the vm is idle (stopped)
001574 102A                  ; returns C set if so, clear if still running
001575 102A                  ;======================================================================
001576 102A 8500D7           vmidle:     mov cy,vmfStop
001577 102D 22                           ret
001578 102E                  
001579 102E                  ;======================================================================
001580 102E                  ; vmsrsp
001581 102E                  ; Sets the return stack pointer (defaults to 0)
001582 102E                  ; input - rsp value in dptr
001583 102E                  ;======================================================================
001584 102E 858234           vmsrsp:		mov vmrstk,dpl
001585 1031 858335           			mov vmrstk+1,dph
001586 1034 AC34                         mov R4,vmrstk               ; reset return stack LSB
001587 1036 AD35                         mov R5,vmrstk+1             ; reset return stack MSB
001588 1038 22               			ret
001589 1039                  
001590 1039                  ;======================================================================
001591 1039                  ; vmdisp
001592 1039                  ; Virtual Machine Dispatch routine.  Each time this is called it will
001593 1039                  ; execute one instruction in the virtual machine.
001594 1039                  ;======================================================================
001595 1039 8E82             vmdisp:     mov   dpl,R6          ; load IP into dptr
001596 103B 8F83                         mov   dph,R7
001597 103D E0                           movx  A,@dptr         ; get opcode
001598 103E A3                           inc   dptr
001599 103F                  
001600 103F F5F0                         mov   B,A
001601 1041 54C0                         anl   A,#0C0h         ;mask off top 2 bits
001602 1043 6024                         jz    vmdis0          ;0 - no literal
001603 1045 B44010                       cjne  A,#040h,vmdis1
001604 1048                              
001605 1048                              ;1 - single byte, read from instruction stream & push
001606 1048 E0                           movx  A,@dptr
001607 1049 A3                           inc   dptr
001608 104A 09                           inc   R1
001609 104B 09                           inc   R1
001610 104C F7                           mov   @R1,A
001611 104D                  
001612 104D                  			;sign extend
001613 104D 33               			rlc   A  		;sign bit to C
001614 104E 74FF             			mov   A,#255	
001615 1050 3400             			addc  A,#0		; 0 if C was set (-ve), FF if cleared
001616 1052 F4               			cpl   A			; so FF if was -ve, 0 if 0 or +ve
001617 1053 09                           inc   R1
001618 1054 F7                           mov   @R1,A
001619 1055 19                           dec   R1
001620 1056 8011                         sjmp  vmdis0
001621 1058                  
001622 1058 B4800C           vmdis1:     cjne  A,#080h,vmdis2
001623 105B                  
001624 105B                              ;2 - word, read from instruction stream & push
001625 105B E0                           movx  A,@dptr
001626 105C A3                           inc   dptr
001627 105D 09                           inc   R1
001628 105E 09                           inc   R1
001629 105F F7                           mov   @R1,A
001630 1060 09                           inc   R1
001631 1061 E0                           movx  A,@dptr
001632 1062 A3                           inc   dptr
001633 1063 F7                           mov   @R1,A
001634 1064 19                           dec   R1
001635 1065 8002                         sjmp  vmdis0
001636 1067                  
001637 1067                  vmdis2:     ; if we get here, the top 2 bits of the opcode are set
001638 1067                              ; and we have an illegal instruction
001639 1067 4107                         ajmp vmill
001640 1069                  
001641 1069                              ; vmdis0 - main dispatch point, any literals have already
001642 1069                              ; been pushed, the opcode is in B & the new IP is in dptr
001643 1069 AE82             vmdis0:     mov   R6,dpl          ; save new IP
001644 106B AF83                         mov   R7,dph
001645 106D E5F0                         mov   A,B
001646 106F 543F                         anl   A,#03Fh         ; zero operand size bits
001647 1071 23                           rl    A               ; 2 bytes per jump table entry
001648 1072 901076                       mov   dptr,#vmjmp     ; jump table base
001649 1075 73                           jmp   @A+dptr         
001650 1076                  
001651 1076 410D             vmjmp:      ajmp  vmnop     ;0   NOP                             ( no operation)
001652 1078 410E                         ajmp  vmadd     ;1   ADD     ia,ib  -  ia + ib       ( integer addition)
001653 107A 411C                         ajmp  vmsub     ;2   SUB     ia,ib  -  ia - ib       ( integer subtraction)
001654 107C 412B                         ajmp  vmmult    ;3   MULT    ia,ib  -  ia * ib       ( integer multiplication)
001655 107E 4148                         ajmp  vmdiv     ;4   DIV     ia,ib  -  ia / ib       ( integer division)
001656 1080 418E                         ajmp  vmmod     ;5   MOD     ia,ib  -  ia MOD ib     ( integer modulus)
001657 1082 41E8                         ajmp  vmand     ;6   AND     ia,ib  -  ia AND ib     ( bitwise and)
001658 1084 41F6                         ajmp  vmor      ;7   OR      ia,ib  -  ia OR ib      ( bitwise or)
001659 1086 6104                         ajmp  vmnot     ;8   NOT     ia     -  NOT ia        ( 1s complement)
001660 1088 413A                         ajmp  vmumul    ;9   UMUL	ua,ub  -  ua * ub       ( unsigned integer multiplication)
001661 108A 4157                         ajmp  vmudiv    ;10  UDIV	ua,ub  -  ua / ub       ( unsigned integer division)
001662 108C 419A                         ajmp  vmumod    ;11  UMOD	ua,ub  -  ua MOD ub     ( unsigned integer modulus)
001663 108E 41D1                         ajmp  vminc     ;12  INC     a		-  a+1		    ( increment )
001664 1090 41DC                         ajmp  vmdec     ;13  DEC	 a		-  a-1			( decrement )
001665 1092 4107                         ajmp  vmill     ;14  ILLEGAL
001666 1094 610E                         ajmp  vmequ     ;15  EQU     a,b    -  a = b         ( bitwise comparison )
001667 1096 612A                         ajmp  vmnequ    ;16  NEQU    a,b    -  a <> b        ( bitwise comparsion )
001668 1098 6146                         ajmp  vmlt      ;17  LT      a,b    -  a < b         ( integer comparison )
001669 109A 615A                         ajmp  vmgt      ;18  GT      a,b    -  a > b         ( integer comparsion )
001670 109C 6174                         ajmp  vmle      ;19  LE      a,b    -  a <= b        ( integer comparison )
001671 109E 618E                         ajmp  vmge      ;20  GE      a,b    -  a >= b        ( integer comparsion )
001672 10A0 61A2                         ajmp  vmdm      ;21  DIVMOD	 ia,ib  -  ia DIV ib, ia MOD ib (combined division/modulus)
001673 10A2 61C0                         ajmp  vmudm     ;22  UDIVMOD ua,ub  -  ua DIV ub, ua MOD ub (unsigned combinded division/modulus)
001674 10A4 61FF                         ajmp  vmmuld    ;23  MULDIV	 ia,ib,ic - (ia * ib) / ic (multiply to 32 bit & scale)
001675 10A6 810B                         ajmp  vmumd     ;24  UMULDIV ua,ub,uc - (ua * ub) / uc (unsigned multiply to 32 bit & scale)
001676 10A8 813C                         ajmp  vmzequ    ;25  ZEQU    bl     -  not-bl        ( boolean not (true if tos=0,else false)
001677 10AA 814D                         ajmp  vmbra     ;26  BRA     offset  -               ( relative branch (IP = IP+offset))
001678 10AC 8158                         ajmp  vmzbra    ;27  ZBRA    flg,off -               ( rel branch if tos = 0)
001679 10AE 816C                         ajmp  vmcall    ;28  CALL    addr    -               ( PUSH(RSP) IP, IP = addr)
001680 10B0 8186                         ajmp  vmenter   ;29  ENTER   n       -               ( set up stack frame for n bytes of locals)
001681 10B2 81A8                         ajmp  vmleave   ;30  LEAVE           -               ( unwind stack frame )
001682 10B4 81BF                         ajmp  vmret     ;31  RET             -               ( POP(RSP) -> IP )
001683 10B6 81D2                         ajmp  vmnret    ;32  NRET    n       -               ( POP(RSP)->IP, RSP-=N )
001684 10B8 81F0                         ajmp  vmccall   ;33  CCALL   addr    -               ( call C fn at addr)
001685 10BA 81FA                         ajmp  vmdup     ;34  DUP     n     -  n,n            ( duplicate TOS )
001686 10BC A106                         ajmp  vmover    ;35  OVER    a,b   -  a,b,a          ( pick 2nd TOS )
001687 10BE A114                         ajmp  vmdrop    ;36  DROP    a     -                 ( drop TOS )
001688 10C0 A117                         ajmp  vmpick    ;37  PICK    (..)n -  (..) n-th item ( pick n-TOS )
001689 10C2 A128                         ajmp  vmswap    ;38  SWAP    a,b   -  b,a            ( swap TOS and 2-TOS )
001690 10C4 A136                         ajmp  vmrepl    ;39  REPL    a,b   -  b              ( replace 2-TOS with TOS )
001691 10C6 A141                         ajmp  vmst      ;40  ST      v,a   -                 ( [a] = v)
001692 10C8 A153                         ajmp  vmld      ;41  LD      a     -  v              ( v = [a] )
001693 10CA A161                         ajmp  vmcst     ;42  CST     c,a   -                 ( character store)
001694 10CC A16E                         ajmp  vmcld     ;43  CLD     a     -  c              ( character fetch)
001695 10CE A179                         ajmp  vmdata    ;44  DATA                            ( skip n bytes,& push original IP)
001696 10D0 4107                         ajmp  vmill     ;45  ILLEGAL
001697 10D2 A18C                         ajmp  vmtor     ;46  TOR     n    -                  ( tos to return stack )
001698 10D4 A1A2                         ajmp  vmfromr   ;47  FROMR        - n                ( return stack to tos )
001699 10D6 A1B9                         ajmp  vmfpadd   ;48  FPADD   n    - FP+n             ( push FP+n )
001700 10D8 A1C2                         ajmp  vmfpld    ;49  FPLD    n    - val              ( return stack[FP+n] ->tos )
001701 10DA A1D4                         ajmp  vmfpst    ;50  FPST    v,n  -                  ( 2tos -> return stack[FP+n] )
001702 10DC 4107                         ajmp  vmill     ;51  ILLEGAL
001703 10DE 4107                         ajmp  vmill     ;52  ILLEGAL
001704 10E0 A1EA                         ajmp  vmfpcld   ;53  FPCLD   n    - c                ( return stack[FP+n] -> tos (char load ))
001705 10E2 A1F9                         ajmp  vmfpcst   ;54  FPCST   c,n  -                  ( 2tos -> (char) return stack[FP+n] )
001706 10E4 C10A                         ajmp  vmhalt    ;55  HALT            -               ( halt execution )
001707 10E6 C110                         ajmp  vmfault   ;56  FAULT   n       -               ( raise fault n & halt execution )
001708 10E8 C118                         ajmp  vmbnd     ;57  BND     v,l,u - v               ( check l<=v<=u (integer), fault if not )
001709 10EA C13E                         ajmp  vmalloc   ;58  ALLOC   n     - a               ( allocates n bytes on RS, returns its addr )
001710 10EC C151                         ajmp  vmmov     ;59  MOV     s,d,n -                 ( move n bytes from source to dest )
001711 10EE 4107                         ajmp  vmill     ;60  ILLEGAL
001712 10F0 4107                         ajmp  vmill     ;61  ILLEGAL
001713 10F2 4107                         ajmp  vmill     ;62  ILLEGAL
001714 10F4 C197                         ajmp  vmesc     ;63  ESC     -                       ( prefix to 2 byte opcodes)
001715 10F6                  
001716 10F6                  ;======================================================================
001717 10F6                  ; Support routines
001718 10F6                  ;======================================================================
001719 10F6                  
001720 10F6                  ;======================================================================
001721 10F6                  ; umul32
001722 10F6                  ; Takes 2 16 bit integers pointed to by R0 & R1 (each points to LSB-
001723 10F6                  ; number stored LSB at lowest numbered address (big-endian)).
001724 10F6                  ; 
001725 10F6                  ; 32 bit product left in vpscratc workspace
001726 10F6                  ; 2 16 bit integers, ia & ib  ial,iah & ibl, ibh
001727 10F6                  ; algorithm as for long multiplication
001728 10F6                  ;           vpscratc +  3 2 1 0
001729 10F6                  ; ial * ibl                 B A
001730 10F6                  ; iah * ibl               B A
001731 10F6                  ; ial * ibh               B A
001732 10F6                  ; iah * ibh             B A
001733 10F6                  ;======================================================================
001734 10F6 E8               umul32:   mov   A,R0
001735 10F7 C0E0                       push  Acc
001736 10F9 E9                         mov   A,R1
001737 10FA C0E0                       push  Acc
001738 10FC                  
001739 10FC                            ; Clear results accumulator
001740 10FC E4                         clr   A
001741 10FD F527                       mov   vpscratc+2,A
001742 10FF F528                       mov   vpscratc+3,A
001743 1101                            ; note bytes 0 & 1 intitalised by ls multiplication
001744 1101                  
001745 1101                            ; ial * ibl - R0 & R1 already point to LS bytes
001746 1101 E7                         mov   A,@R1
001747 1102 86F0                       mov   B,@R0
001748 1104 A4                         mul   AB
001749 1105 F525                       mov   vpscratc+0,A    ; save LS partial product
001750 1107 85F026                     mov   vpscratc+1,B  ; and MS partial product
001751 110A                  
001752 110A                            ; iah * ibl
001753 110A 08                         inc   R0            ; R0 --> iah
001754 110B                  
001755 110B E7                         mov   A,@R1
001756 110C 86F0                       mov   B,@R0
001757 110E A4                         mul   AB
001758 110F 2526                       add   A,vpscratc+1  ; add LS partial product to existing
001759 1111 F526                       mov   vpscratc+1,A
001760 1113 E527                       mov   A,vpscratc+2
001761 1115 35F0                       addc  A,B           ; add carry to B, result -> A
001762 1117 F527                       mov   vpscratc+2,A  ; MS partial product
001763 1119 E528                       mov   A,vpscratc+3    
001764 111B 3400                       addc  A,#0
001765 111D F528                       mov   vpscratc+3,A
001766 111F                  
001767 111F                            ; ial * ibh
001768 111F 18                         dec   R0            ; R0 --> ial
001769 1120 09                         inc   R1            ; R1 --> ibh
001770 1121                  
001771 1121 E7                         mov   A,@R1
001772 1122 86F0                       mov   B,@R0
001773 1124 A4                         mul   AB
001774 1125 2526                       add   A,vpscratc+1  ; add LS partial product to existing
001775 1127 F526                       mov   vpscratc+1,A
001776 1129 E527                       mov   A,vpscratc+2
001777 112B 35F0                       addc  A,B           ; add carry to B, result -> A
001778 112D F527                       mov   vpscratc+2,A  ; MS partial product
001779 112F E528                       mov   A,vpscratc+3    
001780 1131 3400                       addc  A,#0
001781 1133 F528                       mov   vpscratc+3,A
001782 1135                  
001783 1135                            ; iah * ibh
001784 1135 08                         inc   R0            ; R0 --> iah
001785 1136                  
001786 1136 E7                         mov   A,@R1
001787 1137 86F0                       mov   B,@R0
001788 1139 A4                         mul   AB
001789 113A 2527                       add   A,vpscratc+2  ; save LS partial product
001790 113C F527                       mov   vpscratc+2,A
001791 113E E5F0                       mov   A,B
001792 1140 3528                       addc  A,vpscratc+3
001793 1142 F528                       mov   vpscratc+3,A
001794 1144                  
001795 1144 D0E0                       pop   Acc
001796 1146 F9                         mov   R1,A
001797 1147 D0E0                       pop   Acc
001798 1149 F8                         mov   R0,A
001799 114A                  
001800 114A 22                         ret
001801 114B                  
001802 114B                  ;======================================================================
001803 114B                  ; div_16
001804 114B                  ; 32 bit quotient in op_0 to op_3 (ls in op_0, ms in op_3),
001805 114B                  ; 16 bit divisor in R1:R0 (ms in R1, ls in R0)
001806 114B                  ; Result in OP
001807 114B                  ; Remainder in TMP
001808 114B                  ; Also uses A, R5, R6, R7
001809 114B                  ;======================================================================
001810 114B 7F00             div_16:   mov R7,#0
001811 114D 7E00                       mov R6,#0 ; zero out partial remainder
001812 114F 752900                     mov tmp_0, #0
001813 1152 752A00                     mov tmp_1, #0
001814 1155 752B00                     mov tmp_2, #0
001815 1158 752C00                     mov tmp_3, #0
001816 115B                            
001817 115B 7D20                       mov R5,#32    ; loop count
001818 115D 3199             div_lp:   acall shiftd  ; Shift the dividend and return MSB in C
001819 115F EE                         mov A,R6      ; Shift carry into LSB of partial remainder
001820 1160 33                         rlc A
001821 1161 FE                         mov R6,A
001822 1162 EF                         mov A,R7
001823 1163 33                         rlc A
001824 1164 FF                         mov R7,A
001825 1165                            ; now test to see if R7:R6 >= R1:R0
001826 1165 400C                       jc cansub     ; Carry out of R7 shift means R7:R6 > R1:R0
001827 1167 C3                         clr C
001828 1168 EF                         mov A,R7      ; subtract R1 from R7 to see if R1 < R7
001829 1169 99                         subb A,R1     ; A = R7 - R1, carry set if R7 < R1
001830 116A 4011                       jc cantsub
001831 116C                            ; at this point R7>R1 or R7=R1
001832 116C 7005                       jnz cansub    ; jump if R7>R1
001833 116E                            ; if R7 = R1, test for R6>R0
001834 116E C3                         clr C
001835 116F EE                         mov A,R6
001836 1170 98                         subb A,R0     ; A = R6 - R0, carry set if R6 < R0
001837 1171 400A                       jc cantsub
001838 1173                  cansub:
001839 1173                            ; subtract divisor from the partial remainder
001840 1173 C3                         clr C
001841 1174 EE                         mov A,R6
001842 1175 98                         subb A,R0     ; A = R6 - R0
001843 1176 FE                         mov R6,A
001844 1177 EF                         mov A,R7
001845 1178 99                         subb A,R1     ; A = R7 - R1 - Borrow
001846 1179 FF                         mov R7,A
001847 117A D3                         setb C        ; shift one into the quotient
001848 117B 8001                       sjmp quot
001849 117D                  cantsub:
001850 117D                            ; shift a 0 into the quotient
001851 117D C3                         clr C
001852 117E                  quot:     
001853 117E                            ;shift the carry bit into the quotient
001854 117E 31AF                       acall shiftq
001855 1180                            
001856 1180                            ;test for completion
001857 1180 DDDB                       djnz R5,div_lp
001858 1182                  
001859 1182                            ; now all done- move TMP values back into OP
001860 1182 852925                     mov op_0,tmp_0
001861 1185 852A26                     mov op_1,tmp_1
001862 1188 852B27                     mov op_2,tmp_2
001863 118B 852C28                     mov op_3,tmp_3
001864 118E                            ; and remainder into TMP
001865 118E 8E29                       mov tmp_0,R6
001866 1190 8F2A                       mov tmp_1,R7
001867 1192 752B00                     mov tmp_2,#0
001868 1195 752C00                     mov tmp_3,#0
001869 1198 22                         ret
001870 1199                  
001871 1199                  shiftd:   ;shift the dividend one bit to the left and return MSB in C
001872 1199 C3                         clr C
001873 119A E525                       mov A,op_0
001874 119C 33                         rlc A
001875 119D F525                       mov op_0,A
001876 119F E526                       mov A,op_1
001877 11A1 33                         rlc A
001878 11A2 F526                       mov op_1,A
001879 11A4 E527                       mov A,op_2
001880 11A6 33                         rlc A
001881 11A7 F527                       mov op_2,A
001882 11A9 E528                       mov A,op_3
001883 11AB 33                         rlc A
001884 11AC F528                       mov op_3,A
001885 11AE 22                         ret
001886 11AF                  
001887 11AF                  shiftq:   ;shift the quotient one bit to the left and shift C into LSB
001888 11AF E529                       mov A,tmp_0
001889 11B1 33                         rlc A
001890 11B2 F529                       mov tmp_0,A
001891 11B4 E52A                       mov A,tmp_1
001892 11B6 33                         rlc A
001893 11B7 F52A                       mov tmp_1,A
001894 11B9 E52B                       mov A,tmp_2
001895 11BB 33                         rlc A
001896 11BC F52B                       mov tmp_2,A
001897 11BE E52C                       mov A,tmp_3
001898 11C0 33                         rlc A
001899 11C1 F52C                       mov tmp_3,A
001900 11C3 22                         ret
001901 11C4                  
001902 11C4                  ;======================================================================
001903 11C4                  ; vmcmp
001904 11C4                  ; compare tos with 2 to, stack unchanged, 2tos - tos in vpscratc
001905 11C4                  ; a,b - a,b  (a-b -> scratch)
001906 11C4                  ; a>b scratch +ve & != 0
001907 11C4                  ; a<b scratch -ve
001908 11C4                  ; a>=b scratch +ve or 0
001909 11C4                  ; a<=b  scratch -ve or 0
001910 11C4                  ;======================================================================
001911 11C4 E9               vmcmp:    mov   A,R1
001912 11C5 F8                         mov   R0,A
001913 11C6 18                         dec   R0
001914 11C7 18                         dec   R0
001915 11C8 E6                         mov   A,@R0
001916 11C9 C3                         clr   C
001917 11CA 97                         subb  A,@R1
001918 11CB F525                       mov   vpscratc,A
001919 11CD 08                         inc   R0
001920 11CE 09                         inc   R1
001921 11CF E6                         mov   A,@R0
001922 11D0 97                         subb  A,@R1
001923 11D1 F526                       mov   vpscratc+1,A
001924 11D3 19                         dec   R1
001925 11D4 22                         ret
001926 11D5                  
001927 11D5                  ;======================================================================
001928 11D5                  ; vmm2p
001929 11D5                  ; Makes the top 2 entries on the evaluation stack +ve.  Used for 
001930 11D5                  ; signed multiplication, division and modulus.  The appropriate
001931 11D5                  ; sign information should be retrieved before calling this routine
001932 11D5                  ; so that the sign of the result can be correctly set
001933 11D5                  ;======================================================================
001934 11D5 09               vmm2p:	  inc R1
001935 11D6 E7               		  mov A,@R1
001936 11D7 19               		  dec R1
001937 11D8 30E70B           		  jnb Acc.7,vmm2p0 ; skip if ib is +ve or 0
001938 11DB 7400             		  mov A,#0
001939 11DD C3               		  clr C
001940 11DE 97               		  subb A,@R1
001941 11DF F7               		  mov @R1,A
001942 11E0 09               		  inc R1
001943 11E1 7400             		  mov A,#0
001944 11E3 97               		  subb A,@R1
001945 11E4 F7               		  mov  @R1,A
001946 11E5 19               		  dec R1
001947 11E6                  
001948 11E6 19               vmm2p0:	  dec R1			; to point to ms byte of lower word
001949 11E7 E7               		  mov A,@R1
001950 11E8 30E70B           		  jnb Acc.7,vmm2p1 ; skip if ia is +ve or 0
001951 11EB 19               		  dec R1
001952 11EC 7400             		  mov A,#0
001953 11EE C3               		  clr C
001954 11EF 97               		  subb A,@R1
001955 11F0 F7               		  mov @R1,A
001956 11F1 09               		  inc R1
001957 11F2 7400             		  mov A,#0
001958 11F4 97               		  subb A,@R1
001959 11F5 F7               		  mov  @R1,A
001960 11F6                  		
001961 11F6 09               vmm2p1:	  inc R1			; point back to ls byte of upper word
001962 11F7 22               		  ret	
001963 11F8                  
001964 11F8                  
001965 11F8                  ;======================================================================
001966 11F8                  ; vminvn
001967 11F8                  ; negate TOS if sign flag is set.  Used for signed multiplication,
001968 11F8                  ; division and modulus.  These are done as unsigned after the sign
001969 11F8                  ; of the result is worked out and the sign bit set appropriately
001970 11F8                  ;======================================================================
001971 11F8                  vminvn:	  ; invert sign of result if sign bit set.
001972 11F8 30020B           		  jnb vmsign,vmninv ; skip if sign bit clear
001973 11FB 7400             		  mov A,#0
001974 11FD C3               		  clr C
001975 11FE 97               		  subb A,@R1
001976 11FF F7               		  mov @R1,A
001977 1200 09               		  inc R1
001978 1201 7400             		  mov A,#0
001979 1203 97               		  subb A,@R1
001980 1204 F7               		  mov @R1,A
001981 1205 19               		  dec R1
001982 1206                  
001983 1206 22               vmninv:   ret
001984 1207                  
001985 1207                  ;======================================================================
001986 1207                  ; Virtual Machine Instruction Implementations
001987 1207                  ;======================================================================
001988 1207                  
001989 1207                  ;======================================================================
001990 1207                  ; ILLEGAL
001991 1207                  ; Illegal instruction.
001992 1207                  ;======================================================================
001993 1207 753302           vmill:    mov vmfltc,#vIlleg      ; illegal instruction fault
001994 120A D200                       setb vmfStop             ; set stop flag
001995 120C 22                         ret
001996 120D                  
001997 120D                  ;======================================================================
001998 120D                  ; NOP
001999 120D                  ; No-operation
002000 120D                  ;======================================================================
002001 120D 22               vmnop:    ret
002002 120E                  
002003 120E                  ;======================================================================
002004 120E                  ; ADD     
002005 120E                  ; ia,ib  -  ia + ib       ( integer addition)
002006 120E                  ; enter with R1 pointing to lsb of ib (ibl)
002007 120E                  ;======================================================================
002008 120E E9               vmadd:    mov   A,R1    ; R0 --> ibl
002009 120F F8                         mov   R0,A
002010 1210 19                         dec   R1      ; R1 --> iah
002011 1211 19                         dec   R1      ; R1 --> ial
002012 1212 E7                         mov   A,@R1
002013 1213 26                         add   A,@R0
002014 1214 F7                         mov   @R1,A   ; Replace ial
002015 1215 09                         inc   R1      ; R1 --> iah
002016 1216 08                         inc   R0      ; R0 --> ibh
002017 1217 E7                         mov   A,@R1
002018 1218 36                         addc  A,@R0
002019 1219 F7                         mov   @R1,A   ; Replace iah
002020 121A 19                         dec   R1
002021 121B 22                         ret
002022 121C                  
002023 121C                  ;======================================================================
002024 121C                  ; SUB     
002025 121C                  ; ia,ib  -  ia - ib       ( integer subtraction)
002026 121C                  ; 2tos - tos
002027 121C                  ; ibh     
002028 121C                  ; ibl     <-- R1      R0
002029 121C                  ; iah             ==>
002030 121C                  ; ial                 R1
002031 121C                  ;======================================================================
002032 121C E9               vmsub:    mov   A,R1   ; R0 --> ibl
002033 121D F8                         mov   R0,A
002034 121E 19                         dec   R1      ; R1 --> iah
002035 121F 19                         dec   R1      ; R1 --> ial
002036 1220 C3                         clr   C
002037 1221 E7                         mov   A,@R1
002038 1222 96                         subb  A,@R0
002039 1223 F7                         mov   @R1,A   ; Replace ial
002040 1224 09                         inc   R1      ; R1 --> iah
002041 1225 08                         inc   R0      ; R0 --> ibh
002042 1226 E7                         mov   A,@R1
002043 1227 96                         subb  A,@R0
002044 1228 F7                         mov   @R1,A   ; Replace iah
002045 1229 19                         dec   R1      ; point back to lsb of result
002046 122A 22                         ret
002047 122B                  ;======================================================================
002048 122B                  ; MULT    
002049 122B                  ; ia,ib  -  ia * ib       ( integer multiplication)
002050 122B                  ; ibh     
002051 122B                  ; ibl     <-- R1
002052 122B                  ; iah     
002053 122B                  ; ial
002054 122B                  ; 
002055 122B                  ;======================================================================
002056 122B                  vmmult:   ; Capture sign information - xor sign bits of both words
002057 122B 09               		  inc R1
002058 122C E7               		  mov A,@R1 ; ibh
002059 122D 19               		  dec R1
002060 122E 19               		  dec R1
002061 122F 67               		  xrl A,@R1	; iah - if same sign bit 7 = 0
002062 1230 33               		  rlc A		; sign to carry
002063 1231 9202             		  mov vmsign,C
002064 1233 09               		  inc R1
002065 1234                  
002066 1234 31D5             		  acall vmm2p		; make sure operands +ve
002067 1236 513A             		  acall vmumul		; do unsigned multiplcation
002068 1238                  
002069 1238 21F8             		  ajmp vminvn		; invert result if needed
002070 123A                  
002071 123A                  ;======================================================================
002072 123A                  ; UMUL    
002073 123A                  ; ua,ub  -  ua * ub       ( unsigned integer multiplication)
002074 123A                  ;======================================================================
002075 123A E9               vmumul:   mov   A,R1   ; R0 --> ibl
002076 123B F8                         mov   R0,A
002077 123C 19                         dec   R1      ; R1 --> iah
002078 123D 19                         dec   R1      ; R1 --> ial
002079 123E                            
002080 123E 11F6                       acall umul32  ; result in vpscratc
002081 1240                  
002082 1240 E525                       mov A,vpscratc    ; lsb
002083 1242 F7                         mov @R1,A
002084 1243 E526                       mov A,vpscratc+1  ; msb
002085 1245 18                         dec R0            ; pt to iah
002086 1246 F6                         mov @R0,A
002087 1247                  
002088 1247 22                         ret
002089 1248                  
002090 1248                  ;======================================================================
002091 1248                  ; DIV     
002092 1248                  ; ia,ib  -  ia / ib       ( integer division)
002093 1248                  ;======================================================================
002094 1248                  vmdiv:    ; Capture sign information - xor sign bits of both words
002095 1248 09               		  inc R1
002096 1249 E7               		  mov A,@R1 ; ibh
002097 124A 19               		  dec R1
002098 124B 19               		  dec R1
002099 124C 67               		  xrl A,@R1	; iah - if same sign bit 7 = 0
002100 124D 33               		  rlc A		; sign to carry
002101 124E 9202             		  mov vmsign,C
002102 1250 09               		  inc R1
002103 1251                  
002104 1251 31D5             		  acall vmm2p		; make sure operands +ve
002105 1253 5157             		  acall vmudiv		; do unsigned division
002106 1255                  
002107 1255 21F8             		  ajmp vminvn		; invert sign bit if needed
002108 1257                  
002109 1257                  ;======================================================================
002110 1257                  ; UDIV     
002111 1257                  ; ua,ub  -  ua / ub       ( unsigned integer division)
002112 1257                  ;======================================================================
002113 1257 ED               vmudiv:   mov A,R5
002114 1258 C0E0             		  push Acc
002115 125A EE               		  mov A,R6
002116 125B C0E0             		  push Acc
002117 125D EF               		  mov A,R7
002118 125E C0E0             		  push Acc
002119 1260                  
002120 1260 E9               		  mov A,R1
002121 1261 C0E0                       push Acc
002122 1263                  
002123 1263                  		  ; Load dividend
002124 1263 752800                     mov op_3,#0
002125 1266 752700                     mov op_2,#0
002126 1269 E9               		  mov A,R1
002127 126A F8                         mov R0,A
002128 126B 18               		  dec R0
002129 126C 8626             		  mov op_1,@R0
002130 126E 18               		  dec R0
002131 126F 8625             		  mov op_0,@R0
002132 1271                  
002133 1271                  		  ; Load divisor
002134 1271 E9               		  mov A,R1
002135 1272 F8               		  mov R0,A
002136 1273 09               		  inc R1
002137 1274 E7               		  mov A,@R1
002138 1275 F9               		  mov R1,A
002139 1276 E6               		  mov A,@R0
002140 1277 F8               		  mov R0,A
002141 1278                  
002142 1278 314B             		  acall div_16
002143 127A                  
002144 127A D0E0             		  pop Acc
002145 127C A9E0             		  mov R1,Acc
002146 127E                  		
002147 127E                  		  ;get quotient
002148 127E 19                         dec R1
002149 127F A726             		  mov @R1, op_1
002150 1281 19               		  dec R1
002151 1282 A725             		  mov @R1, op_0
002152 1284                  
002153 1284                  		  ; restore registers
002154 1284 D0E0             		  pop Acc
002155 1286 FF               		  mov R7,A
002156 1287 D0E0             		  pop Acc
002157 1289 FE               		  mov R6,A
002158 128A D0E0             		  pop Acc
002159 128C FD               		  mov R5,A
002160 128D 22                         ret
002161 128E                  
002162 128E                  ;======================================================================
002163 128E                  ; MOD     
002164 128E                  ; ia,ib  -  ia MOD ib     ( integer modulus)
002165 128E                  ; result takes sign of dividend (ia)
002166 128E                  ;======================================================================
002167 128E                  vmmod:    ; Capture sign information 
002168 128E 19               		  dec R1
002169 128F E7               		  mov A,@R1
002170 1290 33               		  rlc A		; sign to carry
002171 1291 9202             		  mov vmsign,C
002172 1293 09               		  inc R1
002173 1294                  
002174 1294 31D5             		  acall vmm2p		; make sure operands +ve
002175 1296 519A             		  acall vmumod		; do unsigned multiplcation
002176 1298                  
002177 1298 21F8             		  ajmp vminvn		; invert sign bit if needed
002178 129A                  
002179 129A                  ;======================================================================
002180 129A                  ; UMOD     
002181 129A                  ; ua,ub  -  ua UMOD ub    ( unsigned integer modulus)
002182 129A                  ;======================================================================
002183 129A ED               vmumod:   mov A,R5
002184 129B C0E0             		  push Acc
002185 129D EE               		  mov A,R6
002186 129E C0E0             		  push Acc
002187 12A0 EF               		  mov A,R7
002188 12A1 C0E0             		  push Acc
002189 12A3                  
002190 12A3 E9               		  mov A,R1
002191 12A4 C0E0                       push Acc
002192 12A6                  
002193 12A6                  		  ; Load dividend
002194 12A6 752800                     mov op_3,#0
002195 12A9 752700                     mov op_2,#0
002196 12AC E9               		  mov A,R1
002197 12AD F8                         mov R0,A
002198 12AE 18               		  dec R0
002199 12AF 8626             		  mov op_1,@R0
002200 12B1 18               		  dec R0
002201 12B2 8625             		  mov op_0,@R0
002202 12B4                  
002203 12B4                  		  ; Load divisor
002204 12B4 E9               		  mov A,R1
002205 12B5 F8               		  mov R0,A
002206 12B6 09               		  inc R1
002207 12B7 E7               		  mov A,@R1
002208 12B8 F9               		  mov R1,A
002209 12B9 E6               		  mov A,@R0
002210 12BA F8               		  mov R0,A
002211 12BB                  
002212 12BB 314B             		  acall div_16
002213 12BD                  
002214 12BD D0E0             		  pop Acc
002215 12BF A9E0             		  mov R1,Acc
002216 12C1                  		
002217 12C1                  		  ;get remainder
002218 12C1 19                         dec R1
002219 12C2 A72A             		  mov @R1, tmp_1
002220 12C4 19               		  dec R1
002221 12C5 A729             		  mov @R1, tmp_0
002222 12C7                  
002223 12C7                  		  ; restore registers
002224 12C7 D0E0             		  pop Acc
002225 12C9 FF               		  mov R7,A
002226 12CA D0E0             		  pop Acc
002227 12CC FE               		  mov R6,A
002228 12CD D0E0             		  pop Acc
002229 12CF FD               		  mov R5,A
002230 12D0 22                         ret
002231 12D1                  
002232 12D1                  ;======================================================================
002233 12D1                  ; INC a - a+1
002234 12D1                  ;======================================================================
002235 12D1 E7               vminc:	  mov   A,@R1
002236 12D2 2401             		  add	A,#1
002237 12D4 F7               		  mov   @R1,A
002238 12D5 09               		  inc   R1
002239 12D6 E7               		  mov   A,@R1
002240 12D7 3400             		  addc	A,#0
002241 12D9 F7               		  mov   @R1,A
002242 12DA 19               		  dec   R1
002243 12DB 22               		  ret
002244 12DC                  
002245 12DC                  ;======================================================================
002246 12DC                  ; DEC a - a-1
002247 12DC                  ;======================================================================
002248 12DC C3               vmdec:	  clr   C
002249 12DD E7               		  mov   A,@R1
002250 12DE 9401             		  subb	A,#1
002251 12E0 F7               		  mov   @R1,A
002252 12E1 09               		  inc   R1
002253 12E2 E7               		  mov   A,@R1
002254 12E3 9400             		  subb	A,#0
002255 12E5 F7               		  mov   @R1,A
002256 12E6 19               		  dec   R1
002257 12E7 22               		  ret
002258 12E8                  
002259 12E8                  ;======================================================================
002260 12E8                  ; AND     
002261 12E8                  ; ia,ib  -  ia AND ib     ( bitwise and)
002262 12E8                  ;======================================================================
002263 12E8 E9               vmand:    mov   A,R1   ; R0 --> ibl
002264 12E9 F8                         mov   R0,A
002265 12EA 19                         dec   R1      ; R1 --> iah
002266 12EB 19                         dec   R1      ; R1 --> ial
002267 12EC E7                         mov   A,@R1
002268 12ED 56                         anl   A,@R0
002269 12EE F7                         mov   @R1,A   ; Replace ial
002270 12EF 09                         inc   R1      ; R1 --> iah
002271 12F0 08                         inc   R0      ; R0 --> ibh
002272 12F1 E7                         mov   A,@R1
002273 12F2 56                         anl   A,@R0
002274 12F3 F7                         mov   @R1,A   ; Replace iah
002275 12F4 19                         dec   R1
002276 12F5 22                         ret
002277 12F6                  ;======================================================================
002278 12F6                  ; OR      
002279 12F6                  ; ia,ib  -  ia OR ib      ( bitwise or)
002280 12F6                  ;======================================================================
002281 12F6 E9               vmor:     mov   A,R1   ; R0 --> ibl
002282 12F7 F8                         mov   R0,A
002283 12F8 19                         dec   R1      ; R1 --> iah
002284 12F9 19                         dec   R1      ; R1 --> ial
002285 12FA E7                         mov   A,@R1
002286 12FB 46                         orl   A,@R0
002287 12FC F7                         mov   @R1,A   ; Replace ial
002288 12FD 09                         inc   R1      ; R1 --> iah
002289 12FE 08                         inc   R0      ; R0 --> ibh
002290 12FF E7                         mov   A,@R1
002291 1300 46                         orl   A,@R0
002292 1301 F7                         mov   @R1,A   ; Replace iah
002293 1302 19                         dec   R1
002294 1303 22                         ret
002295 1304                  ;======================================================================
002296 1304                  ; NOT     
002297 1304                  ; ia     -  NOT ia        ( 1s complement)
002298 1304                  ;======================================================================
002299 1304 E9               vmnot:    mov A,r1
002300 1305 F8                         mov R0,A
002301 1306                            
002302 1306 E6                         mov A,@R0
002303 1307 F4                         cpl A
002304 1308 F6                         mov @R0,A
002305 1309                  
002306 1309 08                         inc R0
002307 130A                  
002308 130A E6                         mov A,@R0
002309 130B F4                         cpl A
002310 130C F6                         mov @R0,A
002311 130D                  
002312 130D 22                         ret          
002313 130E                  
002314 130E                  ;======================================================================
002315 130E                  ; EQU     a,b    -  a = b         ( bitwise comparison )
002316 130E                  ;======================================================================
002317 130E E9               vmequ:    mov   A,R1   ; R0 --> ibl
002318 130F F8                         mov   R0,A
002319 1310 19                         dec   R1      ; R1 --> iah
002320 1311 19                         dec   R1      ; R1 --> ial
002321 1312 E7                         mov   A,@R1
002322 1313 66                         xrl   A,@R0
002323 1314 F5F0                       mov   B,A
002324 1316 08                         inc   R0
002325 1317 09                         inc   R1
002326 1318 E7                         mov   A,@R1
002327 1319 66                         xrl   A,@R0
002328 131A 45F0                       orl   A,B     ; if both words were equal: A now 0.
002329 131C 75F000                     mov   B,#0    ; false
002330 131F 7003                       jnz   vmequt  ; jump if not the same (put false)
002331 1321 75F0FF                     mov   B,#0ffh; ; true
002332 1324 A7F0             vmequt:   mov   @R1,B
002333 1326 19                         dec   R1
002334 1327 A7F0                       mov   @R1,B
002335 1329 22                         ret
002336 132A                  
002337 132A                  ;======================================================================
002338 132A                  ; NEQU    a,b    -  a <> b        ( bitwise comparsion )
002339 132A                  ;======================================================================
002340 132A E9               vmnequ:   mov   A,R1   ; R0 --> ibl
002341 132B F8                         mov   R0,A
002342 132C 19                         dec   R1      ; R1 --> iah
002343 132D 19                         dec   R1      ; R1 --> ial
002344 132E E7                         mov   A,@R1
002345 132F 66                         xrl   A,@R0
002346 1330 F5F0                       mov   B,A
002347 1332 08                         inc   R0
002348 1333 09                         inc   R1
002349 1334 E7                         mov   A,@R1
002350 1335 66                         xrl   A,@R0
002351 1336 45F0                       orl   A,B     ; if both words were equal: A now 0.
002352 1338 75F000                     mov   B,#0    ; false
002353 133B 6003                       jz   vmnequf  ; jump if the same (put false)
002354 133D 75F0FF                     mov   B,#0ffh; ; true
002355 1340 A7F0             vmnequf:  mov   @R1,B
002356 1342 19                         dec   R1
002357 1343 A7F0                       mov   @R1,B
002358 1345 22                         ret
002359 1346                  
002360 1346                  ;======================================================================
002361 1346                  ; LT      a,b    -  a < b         ( integer comparison )
002362 1346                  ; If a<b then a-b should be -ve.
002363 1346                  ; Hence if sign bit of (a-b) result is set, return true, else return
002364 1346                  ; false.
002365 1346                  ;======================================================================
002366 1346 31C4             vmlt:     acall vmcmp
002367 1348 75F000                     mov   B,#0            ; default result of false
002368 134B E526                       mov   A,vpscratc+1    ; ms byte of result
002369 134D 30E703                     jnb   ACC.7,vmltf     ; skip if false
002370 1350 75F0FF                     mov   B,#0FFh
002371 1353 E5F0             vmltf:    mov   A,B
002372 1355 19               		  dec   R1
002373 1356 F7                         mov   @R1,A
002374 1357 19                         dec   R1
002375 1358 F7                         mov   @R1,A
002376 1359 22                         ret
002377 135A                  
002378 135A                  ;======================================================================
002379 135A                  ; GT      a,b    -  a > b         ( integer comparsion )
002380 135A                  ; if a>b then a-b is +ve & non-zero
002381 135A                  ;======================================================================
002382 135A 31C4             vmgt:     acall vmcmp
002383 135C 75F000                     mov   B,#0            ; default result of false
002384 135F E525                       mov   A,vpscratc
002385 1361 4526                       orl   A,vpscratc+1    ; zero if result is zero
002386 1363 6008                       jz    vmgtf           ; return false if zero
002387 1365 E526                       mov   A,vpscratc+1    ; ms byte of result
002388 1367 20E703                     jb   ACC.7,vmgtf      ; false if sign bit is set
002389 136A 75F0FF                     mov   B,#0FFh
002390 136D E5F0             vmgtf:    mov   A,B
002391 136F 19               		  dec   R1
002392 1370 F7                         mov   @R1,A
002393 1371 19                         dec   R1
002394 1372 F7                         mov   @R1,A
002395 1373 22                         ret
002396 1374                  
002397 1374                  ;======================================================================
002398 1374                  ; LE      a,b    -  a <= b        ( integer comparison )
002399 1374                  ; if a<=b then a-b is -ve or zero
002400 1374                  ; Note- this is the same as vmgt with the values of true & false
002401 1374                  ; swapped over as a<=b == !(a>b)
002402 1374                  ;======================================================================
002403 1374 31C4             vmle:     acall vmcmp
002404 1376 75F0FF                     mov   B,#0FFh         ; default result of true
002405 1379 E525                       mov   A,vpscratc
002406 137B 4526                       orl   A,vpscratc+1    ; zero if result is zero
002407 137D 6008                       jz    vmlet           ; return true if zero
002408 137F E526                       mov   A,vpscratc+1    ; ms byte of result
002409 1381 20E703                     jb   ACC.7,vmlet      ; true if sign bit is set
002410 1384 75F000                     mov   B,#0            ; set false
002411 1387 E5F0             vmlet:    mov   A,B
002412 1389 19                         dec   R1
002413 138A F7                         mov   @R1,A
002414 138B 19                         dec   R1
002415 138C F7                         mov   @R1,A
002416 138D 22                         ret
002417 138E                  
002418 138E                  ;======================================================================
002419 138E                  ; GE      a,b    -  a >= b        ( integer comparsion )
002420 138E                  ; if a>=b then a-b is +ve or zero (sign bit not set)
002421 138E                  ;======================================================================
002422 138E 31C4             vmge:     acall vmcmp
002423 1390 75F000                     mov   B,#0            ; default result of false
002424 1393 E526                       mov   A,vpscratc+1    ; ms byte of result
002425 1395 20E703                     jb    ACC.7,vmgef     ; if -ve is false
002426 1398 75F0FF                     mov   B,#0FFh
002427 139B E5F0             vmgef:    mov   A,B
002428 139D 19                         dec   R1
002429 139E F7                         mov   @R1,A
002430 139F 19                         dec   R1
002431 13A0 F7                         mov   @R1,A
002432 13A1 22                         ret
002433 13A2                  
002434 13A2                  ;======================================================================
002435 13A2                  ; DIVMOD	 ia,ib  -  ia DIV ib, ia MOD ib (combined division/modulus)
002436 13A2                  ;======================================================================
002437 13A2                  vmdm:   
002438 13A2                  		; capture sign for div
002439 13A2 09               		inc R1
002440 13A3 E7               		mov A,@R1 ; ibh
002441 13A4 19               		dec R1
002442 13A5 19               		dec R1
002443 13A6 67               		xrl A,@R1	; iah - if same sign bit 7 = 0
002444 13A7 33               		rlc A		; sign to carry
002445 13A8 9203             		mov vmsgn2,C
002446 13AA                  
002447 13AA                  		; capture sign for mod
002448 13AA E7               		mov A,@R1
002449 13AB 33               		rlc A		; sign to carry
002450 13AC 9202             		mov vmsign,C
002451 13AE 09               		inc R1
002452 13AF                  
002453 13AF 31D5             		acall vmm2p 	; make operands +ve
002454 13B1 71C0             		acall vmudm		; do unsigned div-mod
002455 13B3 31F8             		acall vminvn	; invert modulus if vmsign set
002456 13B5                  
002457 13B5                  		; invert quotient if vmsgn2 set
002458 13B5 19               		dec R1
002459 13B6 19               		dec R1
002460 13B7 A203             		mov C,vmsgn2
002461 13B9 9202             		mov vmsign,C
002462 13BB 31F8             		acall vminvn
002463 13BD 09               		inc R1
002464 13BE 09               		inc R1
002465 13BF                  
002466 13BF 22               		ret
002467 13C0                  
002468 13C0                  
002469 13C0                  ;======================================================================
002470 13C0                  ; UDIVMOD ua,ub  -  ua DIV ub, ua MOD ub (unsigned combinded division/modulus)
002471 13C0                  ;======================================================================
002472 13C0 ED               vmudm:    mov A,R5
002473 13C1 C0E0             		  push Acc
002474 13C3 EE               		  mov A,R6
002475 13C4 C0E0             		  push Acc
002476 13C6 EF               		  mov A,R7
002477 13C7 C0E0             		  push Acc
002478 13C9                  
002479 13C9 E9               		  mov A,R1
002480 13CA C0E0                       push Acc
002481 13CC                  
002482 13CC                  		  ; Load dividend
002483 13CC 752800                     mov op_3,#0
002484 13CF 752700                     mov op_2,#0
002485 13D2 E9               		  mov A,R1
002486 13D3 F8                         mov R0,A
002487 13D4 18               		  dec R0
002488 13D5 8626             		  mov op_1,@R0
002489 13D7 18               		  dec R0
002490 13D8 8625             		  mov op_0,@R0
002491 13DA                  
002492 13DA                  		  ; Load divisor
002493 13DA E9               		  mov A,R1
002494 13DB F8               		  mov R0,A
002495 13DC 09               		  inc R1
002496 13DD E7               		  mov A,@R1
002497 13DE F9               		  mov R1,A
002498 13DF E6               		  mov A,@R0
002499 13E0 F8               		  mov R0,A
002500 13E1                  
002501 13E1 314B             		  acall div_16
002502 13E3                  
002503 13E3 D0E0             		  pop Acc
002504 13E5 A9E0             		  mov R1,Acc
002505 13E7                  
002506 13E7 A8E0             		  mov R0,Acc
002507 13E9 08               		  inc R0    ; point to msb of dest for remainder
002508 13EA                  
002509 13EA                  		  ;get remainder
002510 13EA A62A             		  mov @R0, tmp_1
002511 13EC 18               		  dec R0
002512 13ED A629             		  mov @R0, tmp_0
002513 13EF                  
002514 13EF                  		  ;get quotient
002515 13EF 18                         dec R0
002516 13F0 A626             		  mov @R0, op_1
002517 13F2 18               		  dec R0
002518 13F3 A625             		  mov @R0, op_0
002519 13F5                  
002520 13F5                  		  ; restore registers
002521 13F5 D0E0             		  pop Acc
002522 13F7 FF               		  mov R7,A
002523 13F8 D0E0             		  pop Acc
002524 13FA FE               		  mov R6,A
002525 13FB D0E0             		  pop Acc
002526 13FD FD               		  mov R5,A
002527 13FE 22                         ret
002528 13FF                  
002529 13FF                  ;======================================================================
002530 13FF                  ; MULDIV	 ia,ib,ic - (ia * ib) / ic (multiply to 32 bit & scale)
002531 13FF                  ;======================================================================
002532 13FF E9               vmmuld: mov A,r1
002533 1400 F8               		mov r0,A
002534 1401                  
002535 1401 E6               		mov A,@R0
002536 1402                  
002537 1402 18               		dec R0
002538 1403 18               		dec R0
002539 1404 66               		xrl A,@R0
002540 1405                  
002541 1405 18               		dec R0
002542 1406 18               		dec R0
002543 1407 66               		xrl A,@R0
002544 1408                  
002545 1408                  		;-WIP HERE TODO!
002546 1408 910B             		acall vmumd
002547 140A 22               		ret
002548 140B                  
002549 140B                  ;======================================================================
002550 140B                  ; UMULDIV ua,ub,uc - (ua * ub) / uc (unsigned multiply to 32 bit & scale)
002551 140B                  ;======================================================================
002552 140B                  vmumd:     
002553 140B ED               		mov A,R5
002554 140C C0E0             		push Acc
002555 140E EE               		mov A,R6
002556 140F C0E0             		push Acc
002557 1411 EF               		mov A,R7
002558 1412 C0E0             		push Acc
002559 1414                  
002560 1414 19               		dec R1			; ignore divisor for the time being
002561 1415 19               		dec R1
002562 1416                  
002563 1416 E9               		mov A,R1
002564 1417 C0E0             		push Acc
002565 1419                  
002566 1419                  		; Do the 16x16 mult to vpscratc
002567 1419 E9               		mov   A,R1   
002568 141A F8               		mov   R0,A
002569 141B 18               		dec   R0      
002570 141C 18               		dec   R0      
002571 141D 11F6             		acall umul32  ; (R0) * (R1) -> result in vpscratc
002572 141F                  
002573 141F                  
002574 141F                  		; 16 bit divisor in R1:R0 (ms in R1, ls in R0)
002575 141F 09               		inc R1
002576 1420 09               		inc R1
002577 1421 E7               		mov A,@R1
002578 1422 F8               		mov R0,A
002579 1423 09               		inc R1
002580 1424 E7               		mov A,@R1
002581 1425 F9               		mov R1,A
002582 1426                  
002583 1426 314B             		acall div_16
002584 1428                  
002585 1428 D0E0             		pop Acc
002586 142A A9E0             		mov R1,Acc
002587 142C                  
002588 142C                  		;get quotient
002589 142C 19               		dec R1
002590 142D A726             		mov @R1, op_1
002591 142F 19               		dec R1
002592 1430 A725             		mov @R1, op_0
002593 1432                  
002594 1432                  		; restore registers
002595 1432 D0E0             		pop Acc
002596 1434 FF               		mov R7,A
002597 1435 D0E0             		pop Acc
002598 1437 FE               		mov R6,A
002599 1438 D0E0             		pop Acc
002600 143A FD               		mov R5,A
002601 143B 22               		ret
002602 143C                  
002603 143C                  
002604 143C                  
002605 143C                  		  
002606 143C                  ;======================================================================
002607 143C                  ; ZEQU    bl     -  not-bl        ( boolean not (true if tos=0,else false)
002608 143C                  ;======================================================================
002609 143C E7               vmzequ:   mov   A,@R1
002610 143D 09                         inc   R1
002611 143E 47                         orl   A,@R1
002612 143F 75F0FF                     mov   B,#0FFH
002613 1442 6003                       jz    vmzeqt
002614 1444 75F000                     mov   B,#0
002615 1447 A7F0             vmzeqt:   mov   @R1,B
002616 1449 19                         dec   R1
002617 144A A7F0                       mov   @R1,B
002618 144C 22                         ret
002619 144D                  
002620 144D                  ;======================================================================
002621 144D                  ; BRA     offset  -               ( relative branch (IP = IP+offset))
002622 144D                  ;======================================================================
002623 144D E7               vmbra:    mov   A,@R1   ; lsb of offset
002624 144E 2E                         add   A,R6    ; add lsb of IP
002625 144F FE                         mov   R6,A
002626 1450 09                         inc   R1
002627 1451 E7                         mov   A,@R1
002628 1452 3F                         addc  A,R7    ; add msb of IP
002629 1453 FF                         mov   R7,A
002630 1454 19                         dec   R1
002631 1455 19                         dec   R1
002632 1456 19                         dec   R1
002633 1457 22                         ret
002634 1458                  
002635 1458                  ;======================================================================
002636 1458                  ; ZBRA    flg,off -               ( rel branch if tos = 0)
002637 1458                  ;======================================================================
002638 1458 E9               vmzbra:   mov A,R1
002639 1459 F8                         mov R0,A
002640 145A 18                         dec R0
002641 145B E6                         mov A,@R0
002642 145C 18                         dec R0
002643 145D 46                         orl A,@R0     ; A=0 iff TOS= 0;
002644 145E 7007                       jnz vmzbrf    ; skiip if not 0
002645 1460                  
002646 1460                            ; Add TOS to IP
002647 1460 E7                         mov   A,@R1   ; lsb of offset
002648 1461 2E                         add   A,R6    ; add lsb of IP
002649 1462 FE                         mov   R6,A
002650 1463 09                         inc   R1
002651 1464 E7                         mov   A,@R1
002652 1465 3F                         addc  A,R7    ; add msb of IP
002653 1466 FF                         mov   R7,A
002654 1467                  
002655 1467 18               vmzbrf:   dec R0
002656 1468 18                         dec R0
002657 1469 E8                         mov A,R0
002658 146A F9                         mov R1,A
002659 146B 22                         ret
002660 146C                  
002661 146C                  ;======================================================================
002662 146C                  ; CALL    addr    -               ( PUSH(RSP) IP, IP = addr)
002663 146C                  ;======================================================================
002664 146C EC               vmcall:   mov   A,R4    ; RSP Low
002665 146D 2402                       add   A,#2    ; Bump RSP for return addr
002666 146F FC                         mov   R4,A
002667 1470 F582                       mov   dpl,A
002668 1472 ED                         mov   A,R5
002669 1473 3400                       addc  A,#0
002670 1475 FD                         mov   R5,A
002671 1476 F583                       mov   dph,A
002672 1478                            ; RSP now incremented & dptr pts to where
002673 1478                            ; return address should go. - write IP
002674 1478                            ; to RSP
002675 1478 EE                         mov  a,R6
002676 1479 F0                         movx @dptr,A
002677 147A A3                         inc  dptr
002678 147B EF                         mov  a,R7
002679 147C F0                         movx @dptr,A
002680 147D                  
002681 147D                            ; Now load up the call address into IP.
002682 147D E7                         mov   A,@R1 
002683 147E FE                         mov   R6,A
002684 147F 09                         inc   R1
002685 1480 E7                         mov   A,@R1
002686 1481 FF                         mov   R7,A
002687 1482 19                         dec   R1
002688 1483 19                         dec   R1
002689 1484 19                         dec   R1
002690 1485                  
002691 1485 22                         ret
002692 1486                  
002693 1486                  ;======================================================================
002694 1486                  ; ENTER   n       -               ( set up stack frame for n bytes of locals)
002695 1486                  ;======================================================================
002696 1486 EC               vmenter:  mov   A,R4      ; Get rsp -> dptr
002697 1487 F582                       mov   dpl,A
002698 1489 ED                         mov   A,R5
002699 148A F583                       mov   dph,A
002700 148C                  
002701 148C A3                         inc   dptr      ; bump RSP (pre-increment)
002702 148D A3                         inc   dptr
002703 148E                  
002704 148E E582                       mov   A,dpl     ; save new stack ptr
002705 1490 FC                         mov   R4,A
002706 1491 E583                       mov   A,dph
002707 1493 FD                         mov   R5,A
002708 1494                  
002709 1494 EA                         mov   A,R2      ; write FP to stack
002710 1495 F0                         movx  @dptr,A
002711 1496 A3                         inc   dptr
002712 1497 EB                         mov   A,R3
002713 1498 F0                         movx  @dptr,A
002714 1499                  
002715 1499                            ; RSP->FP
002716 1499 EC                         mov   A,R4
002717 149A FA                         mov   R2,A
002718 149B ED                         mov   A,R5
002719 149C FB                         mov   R3,A
002720 149D                  
002721 149D                            ; RSP+=N
002722 149D EC                         mov   A,R4
002723 149E 27                         add   A,@R1
002724 149F FC                         mov   R4,A
002725 14A0 09                         inc   R1
002726 14A1 ED                         mov   A,R5
002727 14A2 37                         addc  A,@R1
002728 14A3 FD                         mov   R5,A
002729 14A4 19                         dec   R1
002730 14A5 19                         dec   R1
002731 14A6 19                         dec   R1
002732 14A7                  
002733 14A7 22                         ret
002734 14A8                  
002735 14A8                  ;======================================================================
002736 14A8                  ; LEAVE           -               ( unwind stack frame )
002737 14A8                  ;======================================================================
002738 14A8 EA               vmleave:  mov   A,R2      ; FP->RSP
002739 14A9 FC                         mov   R4,A
002740 14AA EB                         mov   A,R3
002741 14AB FD                         mov   R5,A
002742 14AC                  
002743 14AC                            ; POP FP (leaving dptr pointing to old TOS)
002744 14AC EC                         mov   A,R4
002745 14AD F582                       mov   dpl,A
002746 14AF C3                         clr   C
002747 14B0 9402                       subb  A,#2
002748 14B2 FC                         mov   R4,A
002749 14B3                  
002750 14B3 ED                         mov   A,R5
002751 14B4 F583                       mov   dph,A
002752 14B6 9400                       subb  A,#0
002753 14B8 FD                         mov   R5,A
002754 14B9                  
002755 14B9 E0                         movx  A,@dptr ; get old FP
002756 14BA FA                         mov   R2,A
002757 14BB A3                         inc   dptr
002758 14BC E0                         movx  A,@dptr
002759 14BD FB                         mov   R3,A
002760 14BE                  
002761 14BE 22                         ret
002762 14BF                  
002763 14BF                  ;======================================================================
002764 14BF                  ; RET             -               ( POP(RSP) -> IP )
002765 14BF                  ;======================================================================
002766 14BF EC               vmret:    mov   A,R4      ; RSP low
002767 14C0 F582                       mov   dpl,A
002768 14C2 C3                         clr   C     
002769 14C3 9402                       subb  A,#2
002770 14C5 FC                         mov   R4,A
002771 14C6 ED                         mov   A,R5      ; RSP high
002772 14C7 F583                       mov   dph,A
002773 14C9 9400                       subb  A,#0
002774 14CB FD                         mov   R5,A
002775 14CC                            ; RSP is decremented by 2 bytes, old tos (return addr)
002776 14CC                            ; is now pointed to by DPTR
002777 14CC E0                         movx  A,@dptr   ; return address ls byte
002778 14CD FE                         mov   R6,A      ; stuff in IP low
002779 14CE A3                         inc   dptr
002780 14CF E0                         movx  A,@dptr   ; return address ms byte
002781 14D0 FF                         mov   R7,A      ; stuff in IP high
002782 14D1                  
002783 14D1 22                         ret
002784 14D2                  
002785 14D2                  ;======================================================================
002786 14D2                  ; NRET    n       -               ( POP(RSP)->IP, RSP-=N )
002787 14D2                  ;======================================================================
002788 14D2 EC               vmnret:   mov   A,R4      ; RSP low
002789 14D3 F582                       mov   dpl,A
002790 14D5 C3                         clr   C     
002791 14D6 9402                       subb  A,#2
002792 14D8 FC                         mov   R4,A
002793 14D9 ED                         mov   A,R5      ; RSP high
002794 14DA F583                       mov   dph,A
002795 14DC 9400                       subb  A,#0
002796 14DE FD                         mov   R5,A
002797 14DF                  
002798 14DF                            ; Subtract N from RSP
002799 14DF EC                         mov   A,R4      ; RSP low
002800 14E0 C3                         clr   C
002801 14E1 97                         subb  A,@R1
002802 14E2 FC                         mov   R4,A
002803 14E3 09                         inc   R1   
002804 14E4 ED                         mov   A,R5      ; RSP high
002805 14E5 97                         subb  A,@R1
002806 14E6 FD                         mov   R5,A
002807 14E7 19                         dec   R1        ; drop
002808 14E8 19                         dec   R1
002809 14E9 19                         dec   R1
002810 14EA                  
002811 14EA                            ; RSP is decremented by 2 bytes + N, old tos (return addr)
002812 14EA                            ; is now pointed to by DPTR
002813 14EA E0                         movx  A,@dptr   ; return address ls byte
002814 14EB FE                         mov   R6,A      ; stuff in IP low
002815 14EC A3                         inc   dptr
002816 14ED E0                         movx  A,@dptr   ; return address ms byte
002817 14EE FF                         mov   R7,A      ; stuff in IP high
002818 14EF                  
002819 14EF 22                         ret
002820 14F0                  
002821 14F0                  ;======================================================================
002822 14F0                  ; CCALL   addr    -               ( call C fn at addr)
002823 14F0                  ;======================================================================
002824 14F0 8782             vmccall:  mov   dpl,@R1
002825 14F2 09                         inc   R1
002826 14F3 8783                       mov   dph,@R1
002827 14F5 19                         dec   R1
002828 14F6 19                         dec   R1
002829 14F7 19                         dec   R1
002830 14F8 E4                         clr   A
002831 14F9 73                         jmp     @a+dptr     ; jump to table - use exiting return addr
002832 14FA                  
002833 14FA                  ;======================================================================
002834 14FA                  ; DUP     n     -  n,n            ( duplicate TOS )
002835 14FA                  ;======================================================================
002836 14FA E9               vmdup:    mov  A,R1
002837 14FB F8                         mov  R0,A
002838 14FC 08                         inc  R0
002839 14FD 08                         inc  R0
002840 14FE E7                         mov  A,@R1
002841 14FF F6                         mov  @R0,A
002842 1500 08                         inc  R0
002843 1501 09                         inc  R1
002844 1502 E7                         mov  A,@R1
002845 1503 F6                         mov  @R0,A
002846 1504 09                         inc  R1
002847 1505 22                         ret
002848 1506                  
002849 1506                  ;======================================================================
002850 1506                  ; OVER    a,b   -  a,b,a          ( pick 2nd TOS )
002851 1506                  ;======================================================================
002852 1506 E9               vmover:   mov  A,R1
002853 1507 F8                         mov  R0,A
002854 1508 18                         dec  R0     ; R0 -> 2TOS
002855 1509 18                         dec  R0
002856 150A 09                         inc  R1     ; R1 -> TOS+1
002857 150B 09                         inc  R1
002858 150C E6                         mov  A,@R0
002859 150D F7                         mov  @R1,A
002860 150E 08                         inc  R0
002861 150F 09                         inc  R1
002862 1510 E6                         mov  A,@R0
002863 1511 F7                         mov  @R1,A
002864 1512 19                         dec  R1
002865 1513 22                         ret
002866 1514                  
002867 1514                  ;======================================================================
002868 1514                  ; DROP    a     -                 ( drop TOS )
002869 1514                  ;======================================================================
002870 1514 19               vmdrop:   dec   R1
002871 1515 19                         dec   R1
002872 1516 22                         ret
002873 1517                  
002874 1517                  ;======================================================================
002875 1517                  ; PICK    (..)n -  (..) n-th item ( pick n-TOS )
002876 1517                  ; Note cheat - high byte of n is ignored as SP is only 8-bit anyway.
002877 1517                  ;======================================================================
002878 1517 E7               vmpick:   mov   A,@R1
002879 1518 27                         add   A,@R1   ; 2 * n
002880 1519 F5F0                       mov   B,A
002881 151B E9                         mov   A,R1
002882 151C C3                         clr   C
002883 151D 95F0                       subb  A,B     ; subtract offset from ESP
002884 151F F8                         mov   R0,A
002885 1520                  
002886 1520                            ; copy the word from n-TOS to TOS
002887 1520 E6                         mov   A,@R0
002888 1521 F7                         mov   @R1,A
002889 1522 08                         inc   R0
002890 1523 09                         inc   R1
002891 1524 E6                         mov   A,@R0
002892 1525 F7                         mov   @R1,A
002893 1526 19                         dec   R1
002894 1527                  
002895 1527 22                         ret
002896 1528                  
002897 1528                  ;======================================================================
002898 1528                  ; SWAP    a,b   -  b,a            ( swap TOS and 2-TOS )
002899 1528                  ;======================================================================
002900 1528 E9               vmswap:   mov   A,R1
002901 1529 F8                         mov   R0,A
002902 152A 18                         dec   R0    ; R0 -> 2TOS
002903 152B 18                         dec   R0
002904 152C                            
002905 152C E6                         mov   A,@R0     ; swap ls byte
002906 152D C7                         xch   A,@R1
002907 152E F6               		  mov   @R0,A
002908 152F                  
002909 152F 08                         inc   R0
002910 1530 09                         inc   R1
002911 1531                  
002912 1531 E6                         mov   A,@R0     ; swap ms byte
002913 1532 C7                         xch   A,@R1
002914 1533 F6               		  mov   @R0,A
002915 1534                  
002916 1534 19                         dec   R1
002917 1535 22                         ret
002918 1536                  
002919 1536                  ;======================================================================
002920 1536                  ; REPL    a,b   -  b              ( replace 2-TOS with TOS )
002921 1536                  ;======================================================================
002922 1536 E9               vmrepl:   mov   A,R1
002923 1537 F8                         mov   R0,A
002924 1538 19                         dec   R1   
002925 1539 08                         inc   R0
002926 153A                  
002927 153A E6                         mov   A,@R0
002928 153B F7                         mov   @R1,A
002929 153C                  
002930 153C 18                         dec   R0
002931 153D 19                         dec   R1
002932 153E                  
002933 153E E6                         mov   A,@R0
002934 153F F7                         mov   @R1,A
002935 1540 22                         ret
002936 1541                  
002937 1541                  ;======================================================================
002938 1541                  ; ST      v,a   -                 ( [a] = v)
002939 1541                  ;======================================================================
002940 1541 8782             vmst:     mov   dpl,@R1
002941 1543 09                         inc   R1
002942 1544 8783                       mov   dph,@R1
002943 1546 19                         dec   R1
002944 1547                  
002945 1547 19                         dec   R1
002946 1548 19                         dec   R1
002947 1549                  
002948 1549 E7                         mov   A,@R1
002949 154A F0                         movx  @dptr,A
002950 154B A3                         inc   dptr
002951 154C 09                         inc   R1
002952 154D E7                         mov   A,@R1
002953 154E F0                         movx  @dptr,A
002954 154F 19                         dec   R1
002955 1550                  
002956 1550 19               		  dec   R1
002957 1551 19               		  dec   R1
002958 1552                  
002959 1552 22                         ret
002960 1553                  
002961 1553                  ;======================================================================
002962 1553                  ; LD      a     -  v              ( v = [a] )
002963 1553                  ;======================================================================
002964 1553 8782             vmld:     mov   dpl,@R1
002965 1555 09                         inc   R1
002966 1556 8783                       mov   dph,@R1
002967 1558 19                         dec   R1
002968 1559                            
002969 1559 E0                         movx  A,@dptr
002970 155A F7                         mov   @R1,A
002971 155B                            
002972 155B 09                         inc   R1
002973 155C A3                         inc   dptr
002974 155D                  
002975 155D E0                         movx  A,@dptr
002976 155E F7                         mov   @R1,A
002977 155F                  
002978 155F 19                         dec   R1
002979 1560 22                         ret
002980 1561                  
002981 1561                  ;======================================================================
002982 1561                  ; CST     c,a   -                 ( character store)
002983 1561                  ;======================================================================
002984 1561 8782             vmcst:    mov   dpl,@R1
002985 1563 09                         inc   R1
002986 1564 8783                       mov   dph,@R1
002987 1566 19                         dec   R1
002988 1567                  
002989 1567 19                         dec   R1          ; pt to char
002990 1568 19                         dec   R1
002991 1569                  
002992 1569 E7                         mov   A,@R1       ; store char
002993 156A F0                         movx  @dptr,A
002994 156B                  
002995 156B 19                         dec   R1          ; drop char
002996 156C 19                         dec   R1
002997 156D                  
002998 156D 22                         ret
002999 156E                  
003000 156E                  ;======================================================================
003001 156E                  ; CLD     a     -  c              ( character fetch)
003002 156E                  ;======================================================================
003003 156E 8782             vmcld:    mov   dpl,@R1
003004 1570 09                         inc   R1
003005 1571 8783                       mov   dph,@R1
003006 1573 7700                       mov   @R1,#0      ; zero ms byte of result
003007 1575 19                         dec   R1
003008 1576                            
003009 1576 E0                         movx  A,@dptr     ; get & store char result
003010 1577 F7                         mov   @R1,A
003011 1578                  
003012 1578 22                         ret
003013 1579                  
003014 1579                  ;======================================================================
003015 1579                  ; DATA    n     -  a              ( skip n bytes,& push original IP)
003016 1579                  ; Use for setting up inline data.
003017 1579                  ;======================================================================
003018 1579 8E82             vmdata:   mov   dpl,R6  ; IP low - save original IP - where data is
003019 157B 8F83                       mov   dph,R7  ; IP low
003020 157D E7                         mov   A,@R1
003021 157E 2E                         add   A,R6    ; ls IP+N
003022 157F FE                         mov   R6,A
003023 1580                            
003024 1580 E582                       mov   A,dpl   ; replace ls N with ls Addr
003025 1582 F7                         mov   @R1,A
003026 1583                  
003027 1583 09                         inc   R1
003028 1584                  
003029 1584 E7                         mov   A,@R1   ; ms IP+N
003030 1585 3F                         addc  A,R7
003031 1586 FF                         mov   R7,A
003032 1587                  
003033 1587 E583                       mov   A,dph	; replace MS n with MS addr
003034 1589 F7                         mov   @R1,A
003035 158A                  
003036 158A 19                         dec   R1
003037 158B 22                         ret
003038 158C                  
003039 158C                  
003040 158C                  
003041 158C                  ;======================================================================
003042 158C                  ; TOR     n    -                  ( tos to return stack )
003043 158C                  ;======================================================================
003044 158C EC               vmtor:    mov   A,R4    ; RS low
003045 158D 2402                       add   A,#2
003046 158F F582                       mov   dpl,A
003047 1591 FC                         mov   R4,A
003048 1592 ED                         mov   A,R5    ; RS high
003049 1593 3400                       addc  A,#0
003050 1595 F583                       mov   dph,A
003051 1597 FD                         mov   R5,A
003052 1598                  
003053 1598 E7                         mov   A,@R1
003054 1599 F0                         movx  @dptr,A
003055 159A                  
003056 159A 09                         inc   R1
003057 159B A3                         inc   dptr
003058 159C                  
003059 159C E7                         mov   A,@R1
003060 159D F0                         movx  @dptr,A
003061 159E                  
003062 159E 19                         dec   R1
003063 159F 19                         dec   R1
003064 15A0 19                         dec   R1
003065 15A1                  
003066 15A1 22                         ret
003067 15A2                  
003068 15A2                  ;======================================================================
003069 15A2                  ; FROMR        - n                ( return stack to tos )
003070 15A2                  ;======================================================================
003071 15A2 8C82             vmfromr:  mov   dpl,R4      ;load RSP to dptr
003072 15A4 8D83                       mov   dph,R5      
003073 15A6                            
003074 15A6 09                         inc   R1          ; pt R1 where new TOS will go
003075 15A7 09                         inc   R1
003076 15A8                  
003077 15A8                            ; mov (RSP) to (TOS)
003078 15A8 E0                         movx  A,@dptr
003079 15A9 F7                         mov   @R1,A
003080 15AA 09                         inc   R1
003081 15AB A3                         inc   dptr
003082 15AC E0                         movx  A,@dptr
003083 15AD F7                         mov   @R1,A
003084 15AE 19                         dec   R1
003085 15AF                  
003086 15AF                            ; drop RSP by 2 bytes
003087 15AF EC                         mov   A,R4
003088 15B0 C3                         clr   C
003089 15B1 9402                       subb  A,#2
003090 15B3 FC                         mov   R4,A
003091 15B4 ED                         mov   A,R5
003092 15B5 9400                       subb  A,#0
003093 15B7 FD                         mov   R5,A
003094 15B8                  
003095 15B8 22                         ret
003096 15B9                  
003097 15B9                  ;======================================================================
003098 15B9                  ; FPADD   n    - FP+n             ( push FP+n )
003099 15B9                  ;======================================================================
003100 15B9 E7               vmfpadd:  mov   A,@R1 
003101 15BA 2A                         add   A,R2      ; FP low
003102 15BB F7                         mov   @R1,A
003103 15BC                  
003104 15BC 09                         inc   R1
003105 15BD E7                         mov   A,@R1
003106 15BE 3B                         addc  A,R3      ; FP high
003107 15BF F7                         mov   @R1,A
003108 15C0                  
003109 15C0 19                         dec   R1
003110 15C1 22                         ret
003111 15C2                  
003112 15C2                  ;======================================================================
003113 15C2                  ; FPLD    n    - val              ( return stack[FP+n] ->tos )
003114 15C2                  ;======================================================================
003115 15C2 EA               vmfpld:   mov   A,R2      ; FP low
003116 15C3 27                         add   A,@R1     ; + n low
003117 15C4 F582                       mov   dpl,A     
003118 15C6 09                         inc   R1
003119 15C7 EB                         mov   A,R3
003120 15C8 37                         addc  A,@R1
003121 15C9 F583                       mov   dph,A
003122 15CB 19                         dec   R1        
003123 15CC                  
003124 15CC                            ; now FP+n is in dptr, move data to tos
003125 15CC E0                         movx  A,@dptr
003126 15CD F7                         mov   @R1,A
003127 15CE                            
003128 15CE 09                         inc   R1
003129 15CF A3                         inc   dptr
003130 15D0                  
003131 15D0 E0                         movx  A,@dptr
003132 15D1 F7                         mov   @R1,A
003133 15D2                            
003134 15D2 19                         dec   R1
003135 15D3 22                         ret
003136 15D4                  
003137 15D4                  ;======================================================================
003138 15D4                  ; FPST    v,n  -                  ( 2tos -> return stack[FP+n] )
003139 15D4                  ;======================================================================
003140 15D4 EA               vmfpst:   mov   A,R2      ; FP low
003141 15D5 27                         add   A,@R1     ; + n low
003142 15D6 F582                       mov   dpl,A     
003143 15D8 09                         inc   R1
003144 15D9 EB                         mov   A,R3
003145 15DA 37                         addc  A,@R1
003146 15DB F583                       mov   dph,A
003147 15DD 19                         dec   R1        
003148 15DE                            
003149 15DE 19                         dec   R1
003150 15DF 19                         dec   R1
003151 15E0 E7                         mov   A,@R1
003152 15E1 F0                         movx  @dptr,A
003153 15E2 09                         inc   R1
003154 15E3 A3                         inc   dptr
003155 15E4 E7                         mov   A,@R1
003156 15E5 F0                         movx  @dptr,A
003157 15E6 19                         dec   R1
003158 15E7                  
003159 15E7 19               		  dec   R1
003160 15E8 19               		  dec   R1
003161 15E9 22                         ret
003162 15EA                  
003163 15EA                  ;======================================================================
003164 15EA                  ; FPCLD   n    - c                ( return stack[FP+n] -> tos (char load ))
003165 15EA                  ;======================================================================
003166 15EA EA               vmfpcld:  mov   A,R2      ; FP low
003167 15EB 27                         add   A,@R1     ; + n low
003168 15EC F582                       mov   dpl,A     
003169 15EE 09                         inc   R1
003170 15EF EB                         mov   A,R3
003171 15F0 37                         addc  A,@R1
003172 15F1 F583                       mov   dph,A
003173 15F3 7700                       mov   @R1,#0    ; set MSB of char to 16 bit.
003174 15F5 19                         dec   R1        
003175 15F6                  
003176 15F6                            ; now FP+n is in dptr, move char data to tos
003177 15F6 E0                         movx  A,@dptr
003178 15F7 F7                         mov   @R1,A
003179 15F8                            
003180 15F8 22                         ret
003181 15F9                  
003182 15F9                  ;======================================================================
003183 15F9                  ; FPCST   c,n  -                  ( 2tos -> (char) return stack[FP+n] )
003184 15F9                  ;======================================================================
003185 15F9 EA               vmfpcst:  mov   A,R2      ; FP low
003186 15FA 27                         add   A,@R1     ; + n low
003187 15FB F582                       mov   dpl,A     
003188 15FD 09                         inc   R1
003189 15FE EB                         mov   A,R3
003190 15FF 37                         addc  A,@R1
003191 1600 F583                       mov   dph,A
003192 1602 19                         dec   R1        
003193 1603                            
003194 1603 19                         dec   R1
003195 1604 19                         dec   R1
003196 1605                  
003197 1605 E7                         mov   A,@R1
003198 1606 F0                         movx  @dptr,A
003199 1607                           
003200 1607 19               		  dec   R1
003201 1608 19               		  dec   R1
003202 1609 22                         ret
003203 160A                  
003204 160A                  ;======================================================================
003205 160A                  ; HALT            -               ( halt execution )
003206 160A                  ;======================================================================
003207 160A 753301           vmhalt:   mov vmfltc,#vHalt       ; halt fault
003208 160D D200                       setb vmfstop            ; set stop flag
003209 160F 22                         ret
003210 1610                  
003211 1610                  ;======================================================================
003212 1610                  ; FAULT   n       -               ( raise fault n & halt execution )
003213 1610                  ;======================================================================
003214 1610 E7               vmfault:  mov   A,@R1             ; get (byte) fault code
003215 1611 19               		  dec   R1
003216 1612 19                         dec   R1
003217 1613 F533                       mov vmfltc,A            ;
003218 1615 D200                       setb vmfstop            ; set stop flag
003219 1617 22                         ret
003220 1618                  
003221 1618                  ;======================================================================
003222 1618                  ; BND     v,l,u - v               ( check l<=v<=u (integer), fault if not )
003223 1618                  ;======================================================================
003224 1618 E9               vmbnd:    mov   A,R1				; point r0 at u
003225 1619 F8               		  mov   R0,A
003226 161A                  		  
003227 161A 19               		  dec   R1					; point R1 at v
003228 161B 19                         dec   R1
003229 161C 19                         dec   R1
003230 161D 19                         dec   R1
003231 161E                  
003232 161E                  		  ; R1 points to v, R0 to u
003233 161E                  		  ; if u-v is -ve then fault
003234 161E C3               		  clr 	C
003235 161F E6               		  mov 	A,@R0			   ; u
003236 1620 97               		  subb	A,@R1			   ; - v
003237 1621 08               		  inc	R0				   ; to MS bytes
003238 1622 09               		  inc 	R1
003239 1623 E6               		  mov   A,@R0			   ; u
003240 1624 97               		  subb	A,@R1			   ; - v
003241 1625 18               	      dec	R0
003242 1626 19               		  dec   R1
003243 1627 20E70E           		  jb Acc.7,vmbndf			; -ve if bit 7 set from v > u
003244 162A                  
003245 162A 18               		  dec	R0				   ; point R0 at l
003246 162B 18               		  dec   R0
003247 162C                  
003248 162C                  		  ; R1 points to v, R0 to l
003249 162C                  		  ; if v-l is -ve then fault
003250 162C C3               		  clr 	C
003251 162D E7               		  mov 	A,@R1			   ; v
003252 162E 96               		  subb	A,@R0			   ; - l
003253 162F 08               		  inc	R0
003254 1630 09               		  inc 	R1
003255 1631 E7               		  mov   A,@R1
003256 1632 96               		  subb	A,@R0
003257 1633 19               		  dec   R1
003258 1634 20E701           		  jb Acc.7,vmbndf		   ; -ve if l > v
003259 1637                  		  
003260 1637 22               		  ret	; no fault
003261 1638                  
003262 1638 753303           vmbndf:	  mov 	vmfltc,#vBound
003263 163B D200             		  setb 	vmfStop
003264 163D 22                         ret
003265 163E                  
003266 163E                  ;======================================================================
003267 163E                  ; ALLOC   n     - a               ( allocates n bytes on RS, returns its addr )
003268 163E                  ;======================================================================
003269 163E EC               vmalloc:  mov   A,R4    ; RSP low
003270 163F F582                       mov   dpl,A   ; save temp copy
003271 1641 27                         add   A,@R1   ; bump RSP
003272 1642 FC                         mov   R4,A
003273 1643                            
003274 1643 09                         inc   R1
003275 1644 ED                         mov   A,R5
003276 1645 F583                       mov   dph,A
003277 1647 37                         addc  A,@R1
003278 1648 FD                         mov   R5,A
003279 1649                  
003280 1649 A3               		  inc   dptr	; RSP points to top element on stack so we need
003281 164A A3               		  inc   dptr	; to skip over that to return correct address
003282 164B                  
003283 164B A783                       mov   @R1,dph
003284 164D 19                         dec   R1
003285 164E A782                       mov   @R1,dpl
003286 1650                  
003287 1650 22                         ret
003288 1651                  
003289 1651                  ;======================================================================
003290 1651                  ; MOV     s,d,n -                 ( move n bytes from source to dest )
003291 1651                  ; Uses source pointer in vpstratc + 0 & +1
003292 1651                  ; Dest pointer in vpscratch +2 & +3
003293 1651                  ; Byte count in vpscratc +4 & +5
003294 1651                  ;======================================================================
003295 1651 09               vmmov:    inc   R1            ; n -> vpscratc + 4
003296 1652 872A                       mov   vpscratc+5,@R1
003297 1654 19                         dec   R1
003298 1655 8729                       mov   vpscratc+4,@R1
003299 1657 19               		  dec   R1
003300 1658                  
003301 1658 8728                       mov   vpscratc+3,@R1 ; d -> vpscratc + 2
003302 165A 19                         dec   R1
003303 165B 8727                       mov   vpscratc+2,@R1
003304 165D 19               		  dec   R1
003305 165E                  
003306 165E 8726                       mov   vpscratc+1,@R1  ; s -> vpscratc + 0
003307 1660 19                         dec   R1
003308 1661 8725                       mov   vpscratc+0,@R1
003309 1663 19               		  dec   R1
003310 1664                  
003311 1664 19               		  dec   R1
003312 1665                  
003313 1665 E529             vmmovlp:  mov   A,vpscratc+4
003314 1667 452A                       orl   A,vpscratc+5
003315 1669 602B                       jz    vmmove
003316 166B                  
003317 166B                            ;Get a byte from source & bump source addr
003318 166B 852582                     mov   dpl,vpscratc+0
003319 166E 852683                     mov   dph,vpscratc+1
003320 1671 E0                         movx  A,@dptr
003321 1672 A3                         inc   dptr
003322 1673 858225                     mov   vpscratc+0,dpl
003323 1676 858326                     mov   vpscratc+1,dph
003324 1679                  
003325 1679                            ;Write a byte to dest & bump dest addr
003326 1679 852782                     mov   dpl,vpscratc+2
003327 167C 852883                     mov   dph,vpscratc+3
003328 167F F0                         movx  @dptr,A
003329 1680 A3                         inc   dptr
003330 1681 858227                     mov   vpscratc+2,dpl
003331 1684 858328                     mov   vpscratc+3,dph
003332 1687                  
003333 1687                            ;Decrement counter
003334 1687 E529                       mov   A,vpscratc+4
003335 1689 C3                         clr   C
003336 168A 9401                       subb  A,#1
003337 168C F529                       mov   vpscratc+4,A
003338 168E E52A                       mov   A,vpscratc+5
003339 1690 9400                       subb  A,#0
003340 1692 F52A                       mov   vpscratc+5,A
003341 1694                  
003342 1694 80CF                       sjmp  vmmovlp
003343 1696 22               vmmove:   ret
003344 1697                  
003345 1697                  ;======================================================================
003346 1697                  ; ESC     -                       ( prefix to 2 byte opcodes)
003347 1697                  ;======================================================================
003348 1697 8E82             vmesc:    mov   dpl,R6          ; load IP into dptr
003349 1699 8F83                       mov   dph,R7
003350 169B E0                         movx  A,@dptr         ; get opcode
003351 169C A3                         inc   dptr            ; ++IP
003352 169D AE82                       mov   R6,dpl          ; save IP
003353 169F AF83                       mov   R7,dph
003354 16A1                  
003355 16A1 021800                     ljmp  vxDisp          ; execute extension
003356 16A4                  
003357 16A4                  
003358 16A4                  
003359 16A4                   ;********************* ROBOT VM EXTENSIONS **********************
003360 1800                              .org 1800h   ; 4th 2k page
003361 1800                  ;======================================================================
003362 1800                  ; Robot Virtual Machine support routines
003363 1800                  ; Prefix: vx
003364 1800                  ;======================================================================
003365 1800                  
003366 1800                  ;======================================================================
003367 1800                  ; vxDisp
003368 1800                  ; vm extension dispatch - runs one of the VM extension routines.
003369 1800                  ; Enter with the extension code in A (0..127).
003370 1800                  ;======================================================================
003371 1800 547F             vxDisp:     anl   A,#07Fh         ; make sure top bit is zero
003372 1802 23                           rl    A               ; 2 bytes per jump table entry
003373 1803 901807                       mov   dptr,#vxjmp     ; jump table base
003374 1806 73                           jmp   @A+dptr         
003375 1807                  
003376 1807                  ;======================================================================
003377 1807                  ; vxjmp - VM extension jump table
003378 1807                  ;======================================================================
003379 1807 2107             vxjmp:      ajmp  vxill           ;0  ILLEGAL
003380 1809 212A                         ajmp  vxstop          ;1  Stop processing
003381 180B 212D                         ajmp  vxsini          ;2  intitialise serial port
003382 180D 2130                         ajmp  vxstxa          ;3  transmit character from LS byte of TOS
003383 180F 2136                         ajmp  vxstxc          ;4  Transmit string from code memory pointed to by TOS.
003384 1811 2143                         ajmp  vxstxx          ;5  Transmit string from external data memory pointed to by TOS
003385 1813 2150                         ajmp  vxstx8          ;6  Transmit LS byte of TOS as 2 hex digits
003386 1815 2156                         ajmp  vxst16          ;7  Transmit 16 bit TOS as 4 hex digits
003387 1817 2162                         ajmp  vxsrx           ;8  receive an ascii char & push char code
003388 1819 216D                         ajmp  vxsrx8          ;9  receive a hex encoded byte & push 
003389 181B 2178                         ajmp  vxsr16          ;10  receive a hex encoded 16 bit word & push
003390 181D 2184                         ajmp  vxihex          ;11  read intelhex file in
003391 181F 41A5                         ajmp  vxsmtxba        ;12  Transmit SMBus byte on channel A
003392 1821 41BE                         ajmp  vxsmtxwa        ;13  Transmit SMBus word on channel A
003393 1823 41DD                         ajmp  vxsmrxba        ;14  Receive SMBus byte on channel A
003394 1825 6103                         ajmp  vxsmrxwa        ;15  Receive SMBus word on channel A
003395 1827 612C                         ajmp  vxsmtxbb        ;16  Transmit SMBus byte on channel B
003396 1829 6145                         ajmp  vxsmtxwb        ;17  Transmit SMBus word on channel B
003397 182B 6164                         ajmp  vxsmrxbb        ;18  Receive SMBus byte on channel B
003398 182D 618A                         ajmp  vxsmrxwb        ;19  Receive SMBus word on channel B
003399 182F 61B3                         ajmp  vxrdp1          ;20  Read Port 1
003400 1831 61BD                         ajmp  vxwrp1          ;21  Write Port 1
003401 1833 2107                         ajmp  vxill           ;22  ILLEGAL
003402 1835 2107                         ajmp  vxill           ;23  ILLEGAL
003403 1837 2107                         ajmp  vxill           ;24  ILLEGAL
003404 1839 2198                         ajmp  vxdump          ;25  dump VM state to serial link
003405 183B 2187                         ajmp  vxtset          ;26  set countdown timer from TOS
003406 183D 218D                         ajmp  vxtim           ;27  get value of countdown timer to TOS
003407 183F 2107                         ajmp  vxill           ;28  TOS (bottom 6 bits) to motor control
003408 1841 4116                         ajmp  vxupb10         ;29  Print TOS in base 10 (unsigned)
003409 1843 4140                         ajmp  vxpb10          ;30  Print TOS in base 10 (signed)
003410 1845 2107                         ajmp  vxill           ;31  ILLEGAL
003411 1847 2107                         ajmp  vxill           ;32  ILLEGAL
003412 1849 2107                         ajmp  vxill           ;33  ILLEGAL
003413 184B 2107                         ajmp  vxill           ;34  ILLEGAL
003414 184D 2107                         ajmp  vxill           ;35  ILLEGAL
003415 184F 2107                         ajmp  vxill           ;36  ILLEGAL
003416 1851 2107                         ajmp  vxill           ;37  ILLEGAL
003417 1853 2107                         ajmp  vxill           ;38  ILLEGAL
003418 1855 2107                         ajmp  vxill           ;39  ILLEGAL
003419 1857 2107                         ajmp  vxill           ;40  ILLEGAL
003420 1859 2107                         ajmp  vxill           ;41  ILLEGAL
003421 185B 2107                         ajmp  vxill           ;42  ILLEGAL
003422 185D 2107                         ajmp  vxill           ;43  ILLEGAL
003423 185F 2107                         ajmp  vxill           ;44  ILLEGAL
003424 1861 2107                         ajmp  vxill           ;45  ILLEGAL
003425 1863 2107                         ajmp  vxill           ;46  ILLEGAL
003426 1865 2107                         ajmp  vxill           ;47  ILLEGAL
003427 1867 2107                         ajmp  vxill           ;48  ILLEGAL
003428 1869 2107                         ajmp  vxill           ;49  ILLEGAL
003429 186B 2107                         ajmp  vxill           ;50  ILLEGAL
003430 186D 2107                         ajmp  vxill           ;51  ILLEGAL
003431 186F 2107                         ajmp  vxill           ;52  ILLEGAL
003432 1871 2107                         ajmp  vxill           ;53  ILLEGAL
003433 1873 2107                         ajmp  vxill           ;54  ILLEGAL
003434 1875 2107                         ajmp  vxill           ;55  ILLEGAL
003435 1877 2107                         ajmp  vxill           ;56  ILLEGAL
003436 1879 2107                         ajmp  vxill           ;57  ILLEGAL
003437 187B 2107                         ajmp  vxill           ;58  ILLEGAL
003438 187D 2107                         ajmp  vxill           ;59  ILLEGAL
003439 187F 2107                         ajmp  vxill           ;60  ILLEGAL
003440 1881 2107                         ajmp  vxill           ;61  ILLEGAL
003441 1883 2107                         ajmp  vxill           ;62  ILLEGAL
003442 1885 2107                         ajmp  vxill           ;63  ILLEGAL
003443 1887 2107                         ajmp  vxill           ;64  ILLEGAL
003444 1889 2107                         ajmp  vxill           ;65  ILLEGAL
003445 188B 2107                         ajmp  vxill           ;66  ILLEGAL
003446 188D 2107                         ajmp  vxill           ;67  ILLEGAL
003447 188F 2107                         ajmp  vxill           ;68  ILLEGAL
003448 1891 2107                         ajmp  vxill           ;69  ILLEGAL
003449 1893 2107                         ajmp  vxill           ;70  ILLEGAL
003450 1895 2107                         ajmp  vxill           ;71  ILLEGAL
003451 1897 2107                         ajmp  vxill           ;72  ILLEGAL
003452 1899 2107                         ajmp  vxill           ;73  ILLEGAL
003453 189B 2107                         ajmp  vxill           ;74  ILLEGAL
003454 189D 2107                         ajmp  vxill           ;75  ILLEGAL
003455 189F 2107                         ajmp  vxill           ;76  ILLEGAL
003456 18A1 2107                         ajmp  vxill           ;77  ILLEGAL
003457 18A3 2107                         ajmp  vxill           ;78  ILLEGAL
003458 18A5 2107                         ajmp  vxill           ;79  ILLEGAL
003459 18A7 2107                         ajmp  vxill           ;80  ILLEGAL
003460 18A9 2107                         ajmp  vxill           ;81  ILLEGAL
003461 18AB 2107                         ajmp  vxill           ;82  ILLEGAL
003462 18AD 2107                         ajmp  vxill           ;83  ILLEGAL
003463 18AF 2107                         ajmp  vxill           ;84  ILLEGAL
003464 18B1 2107                         ajmp  vxill           ;85  ILLEGAL
003465 18B3 2107                         ajmp  vxill           ;86  ILLEGAL
003466 18B5 2107                         ajmp  vxill           ;87  ILLEGAL
003467 18B7 2107                         ajmp  vxill           ;88  ILLEGAL
003468 18B9 2107                         ajmp  vxill           ;89  ILLEGAL
003469 18BB 2107                         ajmp  vxill           ;90  ILLEGAL
003470 18BD 2107                         ajmp  vxill           ;91  ILLEGAL
003471 18BF 2107                         ajmp  vxill           ;92  ILLEGAL
003472 18C1 2107                         ajmp  vxill           ;93  ILLEGAL
003473 18C3 2107                         ajmp  vxill           ;94  ILLEGAL
003474 18C5 2107                         ajmp  vxill           ;95  ILLEGAL
003475 18C7 2107                         ajmp  vxill           ;96  ILLEGAL
003476 18C9 2107                         ajmp  vxill           ;97  ILLEGAL
003477 18CB 2107                         ajmp  vxill           ;98  ILLEGAL
003478 18CD 2107                         ajmp  vxill           ;99  ILLEGAL
003479 18CF 2107                         ajmp  vxill           ;100  ILLEGAL
003480 18D1 2107                         ajmp  vxill           ;101  ILLEGAL
003481 18D3 2107                         ajmp  vxill           ;102  ILLEGAL
003482 18D5 2107                         ajmp  vxill           ;103  ILLEGAL
003483 18D7 2107                         ajmp  vxill           ;104  ILLEGAL
003484 18D9 2107                         ajmp  vxill           ;105  ILLEGAL
003485 18DB 2107                         ajmp  vxill           ;106  ILLEGAL
003486 18DD 2107                         ajmp  vxill           ;107  ILLEGAL
003487 18DF 2107                         ajmp  vxill           ;108  ILLEGAL
003488 18E1 2107                         ajmp  vxill           ;109  ILLEGAL
003489 18E3 2107                         ajmp  vxill           ;110  ILLEGAL
003490 18E5 2107                         ajmp  vxill           ;111  ILLEGAL
003491 18E7 2107                         ajmp  vxill           ;112  ILLEGAL
003492 18E9 2107                         ajmp  vxill           ;113  ILLEGAL
003493 18EB 2107                         ajmp  vxill           ;114  ILLEGAL
003494 18ED 2107                         ajmp  vxill           ;115  ILLEGAL
003495 18EF 2107                         ajmp  vxill           ;116  ILLEGAL
003496 18F1 2107                         ajmp  vxill           ;117  ILLEGAL
003497 18F3 2107                         ajmp  vxill           ;118  ILLEGAL
003498 18F5 2107                         ajmp  vxill           ;119  ILLEGAL
003499 18F7 2107                         ajmp  vxill           ;120  ILLEGAL
003500 18F9 2107                         ajmp  vxill           ;121  ILLEGAL
003501 18FB 2107                         ajmp  vxill           ;122  ILLEGAL
003502 18FD 2107                         ajmp  vxill           ;123  ILLEGAL
003503 18FF 2107                         ajmp  vxill           ;124  ILLEGAL
003504 1901 2107                         ajmp  vxill           ;125  ILLEGAL
003505 1903 2107                         ajmp  vxill           ;126  ILLEGAL
003506 1905 2107                         ajmp  vxill           ;127  ILLEGAL
003507 1907                  
003508 1907                  ;======================================================================
003509 1907                  ; vxill
003510 1907                  ; Illegal extension (not implemented)
003511 1907                  ;======================================================================
003512 1907 901910           vxill:      mov dptr, #vxillm
003513 190A 1205E8                       lcall  scomtxc
003514 190D 02160A                       ljmp vmhalt
003515 1910                  
003516 1910 564D5820496C6C65 vxillm:     .db     "VMX Illegal Instruction\r\n\0"
       1918 67616C20496E7374
       1920 72756374696F6E0D
       1928 0A00            
003517 192A                  
003518 192A                  ;======================================================================
003519 192A                  ; vxstop
003520 192A                  ; stop program execution.
003521 192A                  ;======================================================================
003522 192A 02012A           vxstop:     ljmp stop          ; stop execution
003523 192D                  
003524 192D                  ;======================================================================
003525 192D                  ; vxsini
003526 192D                  ; initialise serial port
003527 192D                  ;======================================================================
003528 192D 0205CA           vxsini:     ljmp scominit      ; intitialise serial port
003529 1930                  
003530 1930                  ;======================================================================
003531 1930                  ; vxstxa
003532 1930                  ; transmit character from LS byte of TOS
003533 1930                  ;======================================================================
003534 1930 E7               vxstxa:     mov A,@R1           ; get lsbyte of TOS to transmit
003535 1931 19                           dec R1
003536 1932 19                           dec R1
003537 1933 0205E0                       ljmp scomtxa        ; transmit ascii char in A
003538 1936                  
003539 1936                  ;======================================================================
003540 1936                  ; vxstxc
003541 1936                  ; Transmit string from code memory pointed to by TOS.
003542 1936                  ;======================================================================
003543 1936 E7                 vxstxc:   mov A,@R1
003544 1937 F582                         mov dpl,A
003545 1939 09                           inc R1
003546 193A E7                           mov A,@R1
003547 193B F583                         mov dph,A
003548 193D 19                           dec R1
003549 193E 19                           dec R1
003550 193F 19                           dec R1
003551 1940 0205E8                       ljmp scomtxc       ; transmit string from code mem ptr to by dptr
003552 1943                                                         
003553 1943                  ;======================================================================
003554 1943                  ; vxstxx
003555 1943                  ; Transmit string from external data memory pointed to by TOS
003556 1943                  ;======================================================================
003557 1943 E7                 vxstxx:   mov A,@R1
003558 1944 F582                         mov dpl,A
003559 1946 09                           inc R1
003560 1947 E7                           mov A,@R1
003561 1948 F583                         mov dph,A
003562 194A 19                           dec R1
003563 194B 19                           dec R1
003564 194C 19                           dec R1
003565 194D 0205F2                       ljmp scomtxx       ; transmit string from ext mem ptr to by dptr
003566 1950                  
003567 1950                  ;======================================================================
003568 1950                  ; vxstx8
003569 1950                  ; Transmit LS byte of TOS as 2 hex digits
003570 1950                  ;======================================================================
003571 1950 E7               vxstx8:     mov A,@R1           ; get lsbyte of TOS to transmit
003572 1951 19                           dec R1
003573 1952 19                           dec R1
003574 1953 0205FB                       ljmp scomtx8       ; transmit byte in A as 2 hex digits
003575 1956                  
003576 1956                  ;======================================================================
003577 1956                  ; vxst16
003578 1956                  ; Transmit 16 bit TOS as 4 hex digits
003579 1956                  ;======================================================================
003580 1956 09               vxst16:     inc R1
003581 1957 E7                           mov A,@R1           ; get msbyte of TOS to transmit
003582 1958 1205FB                       lcall scomtx8       ; transmit byte in A as 2 hex digits
003583 195B 19                           dec R1
003584 195C E7                           mov A,@R1           ; get lsbyte of TOS to transmit
003585 195D 19                           dec R1
003586 195E 19                           dec R1
003587 195F 0205FB                       ljmp scomtx8        ; transmit byte in A as 2 hex digits
003588 1962                  
003589 1962                  ;======================================================================
003590 1962                  ; vxsrx
003591 1962                  ; receive an ascii char & push char code
003592 1962                  ;======================================================================
003593 1962 1206A6           vxsrx:      lcall scomrxa       ; receive an ascii char in A
003594 1965 09                           inc R1
003595 1966 09                           inc R1
003596 1967 F7                           mov @R1,A
003597 1968 09                           inc R1
003598 1969 E4                           clr A
003599 196A F7                           mov @R1,A
003600 196B 19                           dec R1
003601 196C 22                           ret
003602 196D                  
003603 196D                  ;======================================================================
003604 196D                  ; vxsrx8
003605 196D                  ; receive a hex encoded byte & push 
003606 196D                  ;======================================================================
003607 196D 1206AE           vxsrx8:     lcall scomrhx8      ; receive a hex encoded byte into A
003608 1970 09                           inc R1
003609 1971 09                           inc R1
003610 1972 F7                           mov @R1,A
003611 1973 09                           inc R1
003612 1974 7700                         mov @R1,#0			; zero ms byte
003613 1976 19                           dec R1
003614 1977 22                           ret
003615 1978                  
003616 1978                  ;======================================================================
003617 1978                  ; vxsr16
003618 1978                  ; receive a hex encoded 16 bit word & push
003619 1978                  ;======================================================================
003620 1978 1206CB           vxsr16:     lcall scomrh16      ; receive a hex encoded word into dptr
003621 197B 09                           inc R1
003622 197C 09                           inc R1
003623 197D A782                         mov @R1, dpl
003624 197F 09                           inc R1
003625 1980 A783                         mov @R1, dph
003626 1982 19                           dec R1
003627 1983 22                           ret
003628 1984                  
003629 1984                  ;======================================================================
003630 1984                  ; vxihex
003631 1984                  ; read intelhex file in
003632 1984                  ;======================================================================
003633 1984 0204D4           vxihex:     ljmp ihexin        ; read intelhex file into data memory
003634 1987                  
003635 1987                  
003636 1987                  ;======================================================================
003637 1987                  ; vxtset
003638 1987                  ; Set timer from TOS
003639 1987                  ;======================================================================
003640 1987 E7               vxtset:     mov A,@R1
003641 1988 19                           dec R1
003642 1989 19                           dec R1
003643 198A 020731                       ljmp settim        ; setup timer - value in A
003644 198D                  
003645 198D                  ;======================================================================
003646 198D                  ; vxtim
003647 198D                  ; Get timer value to TOS
003648 198D                  ;======================================================================
003649 198D 09               vxtim:      inc R1
003650 198E 09                           inc R1
003651 198F 120734                       lcall timer         ; get timer count - return value in A
003652 1992 F7                           mov @R1,A
003653 1993 09                           inc R1
003654 1994 7700                         mov @R1,#0          ; zero MS byte of result
003655 1996 19                           dec R1
003656 1997 22                           ret
003657 1998                  
003658 1998                  
003659 1998                  ;======================================================================
003660 1998                  ; vxdump
003661 1998                  ; dumps state of VM
003662 1998                  ;======================================================================
003663 1998 9019FE           vxdump:     mov dptr,#vxdmp0	  ; ESP
003664 199B 1205E8           		lcall scomtxc
003665 199E E9               		  mov A,R1
003666 199F 1205FB           		  lcall scomtx8
003667 19A2 740A             		  mov A,#'\n'
003668 19A4 1205E0           		  lcall scomtxa
003669 19A7                  
003670 19A7 901A04           		  mov dptr,#vxdmp1	  ; RSP
003671 19AA 1205E8           		  lcall scomtxc
003672 19AD ED               		  mov A,R5
003673 19AE 1205FB           		  lcall scomtx8
003674 19B1 EC               		  mov A,R4
003675 19B2 1205FB           		  lcall scomtx8
003676 19B5 740A             		  mov A,#10 	; linefeed
003677 19B7 1205E0           		  lcall scomtxa
003678 19BA                  
003679 19BA 901A0A           		  mov dptr,#vxdmp2	  ; FP
003680 19BD 1205E8           		  lcall scomtxc
003681 19C0 EB               		  mov A,R3
003682 19C1 1205FB           		  lcall scomtx8
003683 19C4 EA               		  mov A,R2
003684 19C5 1205FB           		  lcall scomtx8
003685 19C8 740A             		  mov A,#10 	; linefeed
003686 19CA 1205E0           		  lcall scomtxa
003687 19CD                  
003688 19CD 901A10           		  mov dptr,#vxdmp3	  ; RSP
003689 19D0 1205E8           		  lcall scomtxc
003690 19D3 EF               		  mov A,R7
003691 19D4 1205FB           		  lcall scomtx8
003692 19D7 EE               		  mov A,R6
003693 19D8 1205FB           		  lcall scomtx8
003694 19DB 740A             		  mov A,#10 	; linefeed
003695 19DD 1205E0           		  lcall scomtxa
003696 19E0                  
003697 19E0                  		  ; Write the stack.
003698 19E0 E9               		  mov A,R1
003699 19E1 F8               		  mov R0,A
003700 19E2 B83E06           vxdmpl:	  cjne R0,#(vmestk-2),vxdmpp
003701 19E5 740A             		  mov A,#10 	; linefeed
003702 19E7 1205E0           		  lcall scomtxa
003703 19EA 22               		  ret
003704 19EB 08               vxdmpp:	  inc R0
003705 19EC E6               		  mov A,@R0
003706 19ED 1205FB           		  lcall scomtx8
003707 19F0 18               		  dec R0
003708 19F1 E6               		  mov A,@R0
003709 19F2 1205FB           		  lcall scomtx8
003710 19F5 740A             		  mov A,#10 	; linefeed
003711 19F7 1205E0           		  lcall scomtxa
003712 19FA 18               		  dec R0
003713 19FB 18               		  dec R0
003714 19FC 80E4             		  sjmp vxdmpl
003715 19FE                  
003716 19FE 4553503A2000     vxdmp0:	  .db "ESP: \0"
003717 1A04 5253503A2000     vxdmp1:   .db "RSP: \0"
003718 1A0A 46503A202000     vxdmp2:   .db "FP:  \0"
003719 1A10 49503A202000     vxdmp3:   .db "IP:  \0"
003720 1A16                  
003721 1A16                  ;======================================================================
003722 1A16                  ; vxupb10
003723 1A16                  ; Prints top of stack in base 10 (unsigned)
003724 1A16                  ; loop version using return stack to reverse the digits
003725 1A16                  ;======================================================================
003726 1A16                  vxupb10:
003727 1A16                  		; push an initial 0 to the return stack to mark end of digits
003728 1A16 09               		inc R1
003729 1A17 09               		inc R1
003730 1A18 7700             		mov @R1,#0
003731 1A1A                  		
003732 1A1A 12158C           		lcall vmtor
003733 1A1D                  
003734 1A1D                  p10in:  
003735 1A1D                  		; push base
003736 1A1D 09               		inc R1
003737 1A1E 09               		inc R1
003738 1A1F 770A             		mov @R1,#10
003739 1A21 09               		inc R1
003740 1A22 7700             		mov @R1,#0
003741 1A24 19               		dec R1
003742 1A25                  
003743 1A25                  		; acc -> acc div 10, acc mod 10
003744 1A25 1213C0           		lcall vmudm		; unsigned div-mod
003745 1A28 E7               		mov a,@R1
003746 1A29 2430             		add a,#'0'
003747 1A2B F7               		mov @R1,a	
003748 1A2C 12158C           		lcall vmtor
003749 1A2F                  
003750 1A2F E7               		mov a,@R1
003751 1A30 09               		inc R1
003752 1A31 47               		orl a,@r1
003753 1A32 19               		dec R1
003754 1A33 70E8             		jnz p10in
003755 1A35                  
003756 1A35 1215A2           p10out:	        lcall vmfromr
003757 1A38 E7               		mov a,@r1
003758 1A39 6004             		jz p10end
003759 1A3B 3130             		acall vxstxa    ; send char
003760 1A3D 80F6             		sjmp p10out
003761 1A3F                  
003762 1A3F 22               p10end:	ret
003763 1A40                  
003764 1A40                  ;======================================================================
003765 1A40                  ; vxpb10
003766 1A40                  ; Prints top of stack in base 10 
003767 1A40                  ;======================================================================
003768 1A40 09               vxpb10:	        inc R1
003769 1A41 E7               		mov A,@R1
003770 1A42 19               		dec R1
003771 1A43 30E7D0           		jnb Acc.7,vxupb10	; no sign if bit 7 clear
003772 1A46                  
003773 1A46                  		; -ve so output a - sign
003774 1A46 742D             		mov a,#'-'
003775 1A48 1205E0           		lcall scomtxa
003776 1A4B                  
003777 1A4B                  		; negate the accumulator & print it.
003778 1A4B C3               		clr C
003779 1A4C 7400             		mov a,#0
003780 1A4E 97               		subb a,@R1
003781 1A4F F7               		mov @R1,a
003782 1A50 09               		inc R1
003783 1A51 7400             		mov a,#0
003784 1A53 97               		subb a,@R1
003785 1A54 F7               		mov @R1,a
003786 1A55 19               		dec R1
003787 1A56 80BE             		sjmp vxupb10
003788 1A58                  
003789 1A58                  ;======================================================================
003790 1A58                  ; pboot
003791 1A58                  ; Runs vm code at 0400h	& prints fault code on completion.
003792 1A58                  ;======================================================================
003793 1A58 901A80           pboot: 		mov dptr, #pbmsg
003794 1A5B 1205E8                           lcall  scomtxc
003795 1A5E                  
003796 1A5E 121000                           lcall vminit  
003797 1A61 900400                           mov dptr,#1024	; start address
003798 1A64 12101B                           lcall vmstart
003799 1A67 121022                           lcall vmrun
003800 1A6A 901A93                           mov dptr, #pbflt
003801 1A6D 1205E8                           lcall  scomtxc
003802 1A70 E533                             mov a,vmfltc	; fault code
003803 1A72 1205FB                           lcall  scomtx8
003804 1A75 740D                             mov a, #13 		; cr
003805 1A77 1205E0                           lcall scomtxa
003806 1A7A 740A                             mov a, #10 		; lf
003807 1A7C 1205E0                           lcall scomtxa
003808 1A7F                  
003809 1A7F 22                               ret
003810 1A80                  
003811 1A80 537461727420564D pbmsg:     .db     "Start VM at 1024\r\n\0"
       1A88 2061742031303234
       1A90 0D0A00          
003812 1A93 564D2073746F7070 pbflt:	   .db	   "VM stopped, code \0"
       1A9B 65642C20636F6465
       1AA3 2000            
003813 1AA5                  
003814 1AA5                  
003815 1AA5                  ;*********************************************************************
003816 1AA5                  ; Virtual machine extensions for SMB routines
003817 1AA5                  ;
003818 1AA5                  ; Notes around VM & SMB:
003819 1AA5                  ; Little endian - least significant byte at lowest numbered address
003820 1AA5                  ; R1 points to top WORD of data stack - need to pre-increment for push, post decrement for pop
003821 1AA5                  ; @R1 is LS byte
003822 1AA5                  ; SMB protocol reads/writes words LS byte first.
003823 1AA5                  ;*********************************************************************
003824 1AA5                  
003825 1AA5                  
003826 1AA5                  ;======================================================================
003827 1AA5                  ; vxsmtxba
003828 1AA5                  ; Virtual machine SMB transmit byte on channel A
003829 1AA5                  ; TOS - Bus address
003830 1AA5                  ; 2TOS - device internal address
003831 1AA5                  ; 3TOS - data to write
003832 1AA5                  ; Write byte:
003833 1AA5                  ; tx Start
003834 1AA5                  ; tx device bus addr
003835 1AA5                  ; tx device addr
003836 1AA5                  ; tx device data
003837 1AA5                  ; txStop
003838 1AA5                  ;======================================================================
003839 1AA5                  
003840 1AA5 12074C           vxsmtxba:       lcall i2csta    ; start
003841 1AA8 E7                               mov A,@R1       ; get lsbyte of tos for bus addr
003842 1AA9 19                               dec R1
003843 1AAA 19                               dec R1
003844 1AAB 120776                           lcall i2ctxa     ; send bus address of device
003845 1AAE                                  
003846 1AAE E7                               mov A,@R1       ; get lsbyte of tos for device internal addr
003847 1AAF 19                               dec R1
003848 1AB0 19                               dec R1
003849 1AB1 120776                           lcall i2ctxa
003850 1AB4                  
003851 1AB4 E7                               mov A,@R1       ; and data byte to send
003852 1AB5 19                               dec R1
003853 1AB6 19                               dec R1
003854 1AB7 120776                           lcall i2ctxa
003855 1ABA 120764                           lcall i2cspa
003856 1ABD 22                               ret
003857 1ABE                  
003858 1ABE                  
003859 1ABE                  
003860 1ABE                  ;======================================================================
003861 1ABE                  ; vxsmtxwa
003862 1ABE                  ; Virtual machine SMB transmit word on channel A
003863 1ABE                  ; TOS - Bus address
003864 1ABE                  ; 2TOS - device internal address
003865 1ABE                  ; 3TOS - data to write
003866 1ABE                  ; Write word:
003867 1ABE                  ; tx Start
003868 1ABE                  ; Tx device bus addr
003869 1ABE                  ; Tx device addr
003870 1ABE                  ; tx device data
003871 1ABE                  ; tx device data
003872 1ABE                  ; tx Stop
003873 1ABE                  ;======================================================================
003874 1ABE                  
003875 1ABE 12074C           vxsmtxwa:       lcall i2csta    ; start
003876 1AC1 E7                               mov A,@R1       ; get lsbyte of tos for bus addr
003877 1AC2 19                               dec R1
003878 1AC3 19                               dec R1
003879 1AC4 120776                           lcall i2ctxa     ; send bus address of device
003880 1AC7                                  
003881 1AC7 E7                               mov A,@R1       ; get lsbyte of tos for device internal addr
003882 1AC8 19                               dec R1
003883 1AC9 19                               dec R1
003884 1ACA 120776                           lcall i2ctxa
003885 1ACD                  
003886 1ACD E7                               mov A,@R1       ; and ls data byte to send
003887 1ACE 120776                           lcall i2ctxa
003888 1AD1 09               		inc R1
003889 1AD2 E7                               mov A,@R1       ; and ms data byte to send
003890 1AD3 19                               dec R1
003891 1AD4 120776                           lcall i2ctxa
003892 1AD7 19                               dec R1
003893 1AD8 19                               dec R1
003894 1AD9 120764                           lcall i2cspa
003895 1ADC 22                               ret
003896 1ADD                  
003897 1ADD                  
003898 1ADD                  ;======================================================================
003899 1ADD                  ; vxsmrxba
003900 1ADD                  ; Virtual machine SMB recive byte on channel A
003901 1ADD                  ; TOS - Bus address
003902 1ADD                  ; 2TOS - device internal address
003903 1ADD                  ; Returns read data on TOS
003904 1ADD                  ; read byte:
003905 1ADD                  ; tx start
003906 1ADD                  ; tx device bus addr
003907 1ADD                  ; tx device addr
003908 1ADD                  ; tx (re)start
003909 1ADD                  ; tx device bus addr + 1
003910 1ADD                  ; rx byte with NACK set
003911 1ADD                  ;======================================================================
003912 1ADD                  
003913 1ADD 12074C           vxsmrxba:       lcall i2csta    ; start
003914 1AE0 E7                               mov A,@R1       ; get lsbyte of tos for bus addr
003915 1AE1 F5F0             		mov B,A		; save it in B for later
003916 1AE3 19                               dec R1
003917 1AE4 19                               dec R1
003918 1AE5 120776                           lcall i2ctxa     ; send bus address of device
003919 1AE8                                  
003920 1AE8 E7                               mov A,@R1       ; get lsbyte of tos for device internal addr
003921 1AE9 120776                           lcall i2ctxa
003922 1AEC                  
003923 1AEC 12074C           		lcall i2csta    ; restart
003924 1AEF                  		
003925 1AEF E5F0                             mov A,B		; saved bus addr
003926 1AF1 4401                             orl A,#1          ; set read bit
003927 1AF3 120776                           lcall i2ctxa     ; send bus read address of device
003928 1AF6                  
003929 1AF6 D3                               setb c          ; want to send NACK as last byte read
003930 1AF7 120794                           lcall i2crxa      ; read the byte
003931 1AFA                  
003932 1AFA F7               		mov @R1,A	; save result as LS byte of TOS
003933 1AFB 09               		inc R1
003934 1AFC 7700             		mov @R1,#0	; clear MS byte of TOS 
003935 1AFE 19               		dec R1
003936 1AFF                                 
003937 1AFF 120764                           lcall i2cspa
003938 1B02 22                               ret
003939 1B03                  
003940 1B03                  ;======================================================================
003941 1B03                  ; vxsmrxwa
003942 1B03                  ; Virtual machine SMB recive word on channel A
003943 1B03                  ; TOS - Bus address
003944 1B03                  ; 2TOS - device internal address
003945 1B03                  ; Returns read data on TOS
003946 1B03                  ; read word:
003947 1B03                  ; tx start
003948 1B03                  ; tx device bus addr
003949 1B03                  ; tx device addr
003950 1B03                  ; tx (re)start
003951 1B03                  ; tx device bus addr + 1
003952 1B03                  ; rx ls byte with NACK clear
003953 1B03                  ; rx ms byte with NACK set
003954 1B03                  ;======================================================================
003955 1B03 12074C           vxsmrxwa:       lcall i2csta    ; start
003956 1B06 E7                               mov A,@R1       ; get lsbyte of tos for bus addr
003957 1B07 F5F0             		mov B,A		; save it in B for later
003958 1B09 19                               dec R1
003959 1B0A 19                               dec R1
003960 1B0B 120776                           lcall i2ctxa     ; send bus address of device
003961 1B0E                                  
003962 1B0E E7                               mov A,@R1       ; get lsbyte of tos for device internal addr
003963 1B0F 120776                           lcall i2ctxa
003964 1B12                  
003965 1B12 12074C           		lcall i2csta    ; restart
003966 1B15                  		
003967 1B15 E5F0                             mov A,B		; saved bus addr
003968 1B17 4401                             orl A,#1          ; set read bit
003969 1B19 120776                           lcall i2ctxa     ; send bus read address of device
003970 1B1C                  
003971 1B1C C3                               clr c           ; want to send ACK as not last byte read
003972 1B1D 120794                           lcall i2crxa      ; read the byte
003973 1B20                  
003974 1B20 F7               		mov @R1,A	; save result as LS byte of TOS
003975 1B21 09               		inc R1
003976 1B22                  
003977 1B22 D3                               setb c          ; want to send NACK as last byte read
003978 1B23 120794                           lcall i2crxa      ; read the byte
003979 1B26                  
003980 1B26 F7               		mov @R1,A	; save result as MS byte of TOS 
003981 1B27 19               		dec R1
003982 1B28                                 
003983 1B28 120764                           lcall i2cspa
003984 1B2B 22                               ret
003985 1B2C                  
003986 1B2C                  
003987 1B2C                  
003988 1B2C                  
003989 1B2C                  
003990 1B2C                  
003991 1B2C                  ;======================================================================
003992 1B2C                  ; vxsmtxbb
003993 1B2C                  ; Virtual machine SMB transmit byte on channel B
003994 1B2C                  ; TOS - Bus address
003995 1B2C                  ; 2TOS - device internal address
003996 1B2C                  ; 3TOS - data to write
003997 1B2C                  ; Write byte:
003998 1B2C                  ; tx Start
003999 1B2C                  ; tx device bus addr
004000 1B2C                  ; tx device addr
004001 1B2C                  ; tx device data
004002 1B2C                  ; txStop
004003 1B2C                  ;======================================================================
004004 1B2C                  
004005 1B2C 1207B6           vxsmtxbb:       lcall i2cstb    ; start
004006 1B2F E7                               mov A,@R1       ; get lsbyte of tos for bus addr
004007 1B30 19                               dec R1
004008 1B31 19                               dec R1
004009 1B32 1207E0                           lcall i2ctxb     ; send bus address of device
004010 1B35                                  
004011 1B35 E7                               mov A,@R1       ; get lsbyte of tos for device internal addr
004012 1B36 19                               dec R1
004013 1B37 19                               dec R1
004014 1B38 1207E0                           lcall i2ctxb
004015 1B3B                  
004016 1B3B E7                               mov A,@R1       ; and data byte to send
004017 1B3C 19                               dec R1
004018 1B3D 19                               dec R1
004019 1B3E 1207E0                           lcall i2ctxb
004020 1B41 1207CE                           lcall i2cspb
004021 1B44 22                               ret
004022 1B45                  
004023 1B45                  
004024 1B45                  
004025 1B45                  ;======================================================================
004026 1B45                  ; vxsmtxwb
004027 1B45                  ; Virtual machine SMB transmit word on channel B
004028 1B45                  ; TOS - Bus address
004029 1B45                  ; 2TOS - device internal address
004030 1B45                  ; 3TOS - data to write
004031 1B45                  ; Write word:
004032 1B45                  ; tx Start
004033 1B45                  ; Tx device bus addr
004034 1B45                  ; Tx device addr
004035 1B45                  ; tx device data
004036 1B45                  ; tx device data
004037 1B45                  ; tx Stop
004038 1B45                  ;======================================================================
004039 1B45                  
004040 1B45 1207B6           vxsmtxwb:       lcall i2cstb    ; start
004041 1B48 E7                               mov A,@R1       ; get lsbyte of tos for bus addr
004042 1B49 19                               dec R1
004043 1B4A 19                               dec R1
004044 1B4B 1207E0                           lcall i2ctxb     ; send bus address of device
004045 1B4E                                  
004046 1B4E E7                               mov A,@R1       ; get lsbyte of tos for device internal addr
004047 1B4F 19                               dec R1
004048 1B50 19                               dec R1
004049 1B51 1207E0                           lcall i2ctxb
004050 1B54                  
004051 1B54 E7                               mov A,@R1       ; and ls data byte to send
004052 1B55 1207E0                           lcall i2ctxb
004053 1B58 09               		inc R1
004054 1B59 E7                               mov A,@R1       ; and ms data byte to send
004055 1B5A 19                               dec R1
004056 1B5B 1207E0                           lcall i2ctxb
004057 1B5E 19                               dec R1
004058 1B5F 19                               dec R1
004059 1B60                  
004060 1B60 1207CE                           lcall i2cspb
004061 1B63 22                               ret
004062 1B64                  
004063 1B64                  
004064 1B64                  ;======================================================================
004065 1B64                  ; vxsmrxbb
004066 1B64                  ; Virtual machine SMB recive byte on channel B
004067 1B64                  ; TOS - Bus address
004068 1B64                  ; 2TOS - device internal address
004069 1B64                  ; Returns read data on TOS
004070 1B64                  ; read byte:
004071 1B64                  ; tx start
004072 1B64                  ; tx device bus addr
004073 1B64                  ; tx device addr
004074 1B64                  ; tx (re)start
004075 1B64                  ; tx device bus addr + 1
004076 1B64                  ; rx byte with NACK set
004077 1B64                  ;======================================================================
004078 1B64                  
004079 1B64 1207B6           vxsmrxbb:       lcall i2cstb    ; start
004080 1B67 E7                               mov A,@R1       ; get lsbyte of tos for bus addr
004081 1B68 F5F0             		mov B,A		; save it in B for later
004082 1B6A 19                               dec R1
004083 1B6B 19                               dec R1
004084 1B6C 1207E0                           lcall i2ctxb     ; send bus address of device
004085 1B6F                                  
004086 1B6F E7                               mov A,@R1       ; get lsbyte of tos for device internal addr
004087 1B70 1207E0                           lcall i2ctxb
004088 1B73                  
004089 1B73 1207B6           		lcall i2cstb    ; restart
004090 1B76                  		
004091 1B76 E5F0                             mov A,B		; saved bus addr
004092 1B78 4401                             orl A,#1          ; set read bit
004093 1B7A 1207E0                           lcall i2ctxb     ; send bus read address of device
004094 1B7D                  
004095 1B7D D3                               setb c          ; want to send NACK as last byte read
004096 1B7E 1207FE                           lcall i2crxb      ; read the byte
004097 1B81                  
004098 1B81 F7               		mov @R1,A	; save result as LS byte of TOS
004099 1B82 09               		inc R1
004100 1B83 7700             		mov @R1,#0	; clear MS byte of TOS 
004101 1B85 19               		dec R1
004102 1B86                                 
004103 1B86 1207CE                           lcall i2cspb
004104 1B89 22                               ret
004105 1B8A                  
004106 1B8A                  ;======================================================================
004107 1B8A                  ; vxsmrxwb
004108 1B8A                  ; Virtual machine SMB recive word on channel B
004109 1B8A                  ; TOS - Bus address
004110 1B8A                  ; 2TOS - device internal address
004111 1B8A                  ; Returns read data on TOS
004112 1B8A                  ; read word:
004113 1B8A                  ; tx start
004114 1B8A                  ; tx device bus addr
004115 1B8A                  ; tx device addr
004116 1B8A                  ; tx (re)start
004117 1B8A                  ; tx device bus addr + 1
004118 1B8A                  ; rx ls byte with NACK clear
004119 1B8A                  ; rx ms byte with NACK set
004120 1B8A                  ;======================================================================
004121 1B8A 1207B6           vxsmrxwb:       lcall i2cstb    ; start
004122 1B8D E7                               mov A,@R1       ; get lsbyte of tos for bus addr
004123 1B8E F5F0             		mov B,A		; save it in B for later
004124 1B90 19                               dec R1
004125 1B91 19                               dec R1
004126 1B92 1207E0                           lcall i2ctxb     ; send bus address of device
004127 1B95                                  
004128 1B95 E7                               mov A,@R1       ; get lsbyte of tos for device internal addr
004129 1B96 1207E0                           lcall i2ctxb
004130 1B99                  
004131 1B99 1207B6           		lcall i2cstb    ; restart
004132 1B9C                  		
004133 1B9C E5F0                             mov A,B		; saved bus addr
004134 1B9E 4401                             orl A,#1          ; set read bit
004135 1BA0 1207E0                           lcall i2ctxb     ; send bus read address of device
004136 1BA3                  
004137 1BA3 C3                               clr c           ; want to send ACK as not last byte read
004138 1BA4 1207FE                           lcall i2crxb      ; read the byte
004139 1BA7                  
004140 1BA7 F7               		mov @R1,A	; save result as LS byte of TOS
004141 1BA8 09               		inc R1
004142 1BA9                  
004143 1BA9 D3                               setb c          ; want to send NACK as last byte read
004144 1BAA 1207FE                           lcall i2crxb      ; read the byte
004145 1BAD                  
004146 1BAD F7               		mov @R1,A	; save result as MS byte of TOS 
004147 1BAE 19               		dec R1
004148 1BAF                                 
004149 1BAF 1207CE                           lcall i2cspb
004150 1BB2 22                               ret
004151 1BB3                  
004152 1BB3                  ;======================================================================
004153 1BB3                  ; vxrdp1
004154 1BB3                  ; Read port 1 and return data as LSB of TOS
004155 1BB3                  ;======================================================================
004156 1BB3 E590             vxrdp1:         mov A,p1
004157 1BB5 09                               inc R1
004158 1BB6 09                               inc R1
004159 1BB7 F7                               mov @R1,A
004160 1BB8 09                               inc R1
004161 1BB9 7700                             mov @R1,#0
004162 1BBB 19                               dec R1
004163 1BBC 22                               ret
004164 1BBD                  
004165 1BBD                  ;======================================================================
004166 1BBD                  ; vxwrp1
004167 1BBD                  ; Write port 1 with LSB of TOS
004168 1BBD                  ;======================================================================
004169 1BBD E7               vxwrp1:        mov A,@R1
004170 1BBE F590                            mov p1,A
004171 1BC0 19                              dec R1
004172 1BC1 19                              dec R1
004173 1BC2 22                              ret
004174 1BC3                  
004175 1BC3                  
004176 1BC3                  
004177 1BC3                  
004178 1BC3                  
004179 1BC3                   ;******************************  END  *******************************
004180 1BC3                   .end

